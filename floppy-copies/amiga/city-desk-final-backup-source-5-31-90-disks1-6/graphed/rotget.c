

#include "exec/types.h"
#include "intuition/intuition.h"
#include "graphics/gfxbase.h"
#include "graphed.h"
#include "desk.h"

rotget(screen,rp)
struct Screen *screen;
struct RastPort *rp;
{

struct IntuiMessage *mess,*GetMsg();
ULONG mclass;
USHORT mcode;
LONG Mx,My;
int temp1,rff;
USHORT *dataa,*datab;

static USHORT rotbData[] =
{

0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFF00,0x8000,
0x0080,0x0001,0x0000,0x0100,0x803C,0x0080,
0x1E01,0x003C,0x0100,0x8003,0x0080,0x0101,
0x0002,0x0100,0x8000,0x8080,0x0081,0x0001,
0x0100,0x8000,0x4080,0x0041,0x0200,0x8100,
0x8001,0x5080,0x0041,0x0700,0x8100,0x8000,
0xE080,0x0041,0x0A80,0x8100,0x8000,0x4080,
0x0041,0x0200,0x8100,0x8000,0x0080,0x0441,
0x0200,0x8100,0x8000,0x0080,0x0981,0x0101,
0x0100,0x8000,0x0080,0x1F01,0x0082,0x0100,
0x8000,0x0080,0x0801,0x007C,0x0100,0x8000,
0x0080,0x0401,0x0000,0x0100,0xFFFF,0xFFFF,
0xFFFF,0xFFFF,0xFF00,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0008,
0x776F,0x726B,0x696E,0x672E,0x2E2E,0x6E6C,
0x792E,0x0A0A,0x2062,0x6520,0x6672,0x6565,
0x6C79,0x2064,0x6973,0x7472,0x6962,0x7574,
0x6564,0x2066,0x6F72,0x206E,0x6F6E,0x2D70,
0x726F,0x6669,0x740A,0x0000,0x0000,0x0000,
};

static struct BitMap rotb =
{
0,17,0,4,0,
/*72,32,1,     Width, Height, Depth */
0,
0,0,0,0,0,0,0
};



static USHORT rotaData[] =
{

0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,
0xFFFF,0xFFFF,0xFFFF,0x8000,0xC000,0x0000,
0x0000,0xC000,0x0000,0x0000,0xC000,0x0000,
0x0000,0x8000,0xC000,0x0FF0,0x0000,0xC000,
0x07F8,0x0000,0xC000,0x07F8,0x0000,0x8000,
0xC000,0x000E,0x0000,0xC000,0x0007,0x0000,
0xC000,0x0007,0x0000,0x8000,0xC000,0x0001,
0x8000,0xC000,0x0000,0x8000,0xC000,0x0000,
0x8000,0x8000,0xC000,0x0000,0x4000,0xC000,
0x0000,0x4000,0xC002,0x0000,0x4000,0x8000,
0xC000,0x0002,0x2200,0xC000,0x0000,0x2000,
0xC00F,0x8000,0x2000,0x8000,0xC000,0x0001,
0xAC00,0xC000,0x0000,0x2000,0xC032,0x6000,
0x2000,0x8000,0xC000,0x0000,0x7000,0xC000,
0x0000,0x2000,0xC002,0x0000,0x2000,0x8000,
0xC000,0x0000,0x0000,0xC000,0x0060,0x4000,
0xC001,0x0000,0x4000,0x8000,0xC000,0x0000,
0x0000,0xC000,0x0183,0x8000,0xC000,0x8000,
0x8000,0x8000,0xC000,0x0000,0x0000,0xC000,
0x03FE,0x0000,0xC000,0x7007,0x0000,0x8000,
0xC000,0x0000,0x0000,0xC000,0x0180,0x0000,
0xC000,0x0FF8,0x0000,0x8000,0xC000,0x0000,
0x0000,0xC000,0x0060,0x0000,0xC000,0x0000,
0x0000,0x8000,0xFFFF,0xFFFF,0xFFFF,0xFFFF,
0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0x8000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
};

static struct BitMap rota =
{
0,17,0,4,0,
/*145,31,1,     Width, Height, Depth */
0,
0,0,0,0,0,0,0
};


struct NewWindow rotWindow;
struct Window *rotwin;

rotWindow.Height = 15;
if (screen->Width > 400) {
   rotWindow.LeftEdge = 280;
   rotWindow.Width = 145;
   }
else {
   rotWindow.LeftEdge = 140;
   rotWindow.Width = 72;
   }
if (screen->Height <210)
   rotWindow.TopEdge = 175;
else
   rotWindow.TopEdge = 375;
rotWindow.DetailPen = 0;
rotWindow.BlockPen = 1<<screen->BitMap.Depth -1;
rotWindow.Title = NULL;
rotWindow.Flags = ACTIVATE | RMBTRAP | SMART_REFRESH | BORDERLESS;
rotWindow.IDCMPFlags = MOUSEBUTTONS;
rotWindow.Type = CUSTOMSCREEN;
rotWindow.FirstGadget = NULL;
rotWindow.CheckMark = NULL;
rotWindow.Screen = screen;
rotWindow.BitMap = NULL;
rotWindow.MinWidth = 0;
rotWindow.MinHeight = 0;
rotWindow.MaxWidth = 640;
rotWindow.MaxHeight = 200;

rotwin = (struct Window *)OpenWindow(&rotWindow);

if (rotwin == NULL)
   exit(10);

rota.BytesPerRow = RASSIZE(145,1);
rotb.BytesPerRow = RASSIZE(72,1);
dataa = AllocMem(RASSIZE(145,rota.Rows),MEMF_CHIP);
movmem(&rotaData[0],dataa,RASSIZE(145,rota.Rows));
rota.Planes[0] = dataa;
rota.Planes[1] = dataa;
rota.Planes[2] = dataa;
rota.Planes[3] = dataa;
datab = AllocMem(RASSIZE(72,rotb.Rows),MEMF_CHIP);
movmem(&rotbData[0],datab,RASSIZE(72,rotb.Rows));
rotb.Planes[0] = datab;
rotb.Planes[1] = datab;
rotb.Planes[2] = datab;
rotb.Planes[3] = datab;

if (screen->Width > 400)
   rp->BitMap = &rota;
else
   rp->BitMap = &rotb;

ClipBlit (rp,0,0,rotwin->RPort,0,
      0,rota.BytesPerRow * 8 ,rota.Rows ,0xee,1,0);

ModifyIDCMP(rotwin, RAWKEY | MOUSEBUTTONS);

while (TRUE)  {
   Wait(1<<rotwin->UserPort->mp_SigBit);
   while((mess = GetMsg(rotwin->UserPort))!= 0) {

      mclass = mess->Class;
      mcode = mess->Code;
      Mx = mess->MouseX;
      My = mess->MouseY;
      ReplyMsg(mess);

      if (mclass == RAWKEY && 0x40 == (char) mcode ) {
         rff = -1;
         goto end1;
         }
      if (mclass == MOUSEBUTTONS && mcode == SELECTDOWN)  {
         temp1 = 72/3;
         if (screen->Width > 400)
            temp1 = 145/3;
         rff = 0;
         if (Mx >temp1)
            rff = 1;
         if (Mx >temp1*2)
            rff = 2;
         goto end1;
         }
      }
   }
end1:
CloseWindow(rotwin);
FreeMem(dataa,RASSIZE(145,rota.Rows));
FreeMem(datab,RASSIZE(72,rotb.Rows));
return(rff);
}

