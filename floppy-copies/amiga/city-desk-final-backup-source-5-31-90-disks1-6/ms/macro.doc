Macros are defined using the "def" or "define" command.  The first argument
is the macro name, and the second is the replacement text, or definition.
The definition must be in single or double quotes if it contains any spaces,
commas, semicolons, or the end-command character (right bracket).  It's a
good idea to use quotes if it's anything other than a single short word.
Examples:
[define ab "abcdefghijklmnopqrstuvwxyz"]
[define joe 'Joseph "Jumpin Joe" Smith, the party of the first part']
[def sub "[vskip -.5pc]{1}[vskip 0]"]
[def sup "[vskip +.5pc]{1}[vskip 0]"]
[def tex 'T[sub E]X']
[def eq "E = m * c[sup '2']"]

A macro is called much like a command.  Start with the open bracket (or the
start-command character), then the macro name, then the parameters, if any,
separated by spaces, and the close bracket (end-command char).  You may also
mix commands and macro calls in the same pair of brackets, separating them
by commas or semicolons.
Examples:
The alphabet is [ab].
Whereas the plaintiff, [joe], has been using the [tex] formatting system...
Einstein's famous formula, [eq], can convert simple H[sub 2]O to energy.

Macros can have any number of parameters, including none.  Parameters are
included in the call just like they are for any normal commands.  Separate
them by spaces (only! not commas) and enclose any strings that contain
spaces, commas, semicolons, or the end-command character in single or double
quotes.

Parameters are referenced in the definition by enclosing the parameter
number in curly braces (the brace chars may be redefined).  The number must
be between 1 and the actual number of parameters given; if not, an error
message results.  The parameter text is substituted in place of the
parameter reference.  A parameter reference may be used as an actual
parameter to another macro call.
Examples:
[define large "[mag {1}]{2}[mag 1.0]"]
[define standard "[topaz 8,p,fj]"]
[def section "[diamond 12,bold,cj,large 1.5 'Section {1} - {2}',standard]"]
[section 3 'New features in 2.0']\nThese are the new features.....

Arithmetic expressions are now allowed in all commands that take numeric
arguments.  The functions available are add(+), subtract(-), multiply(*),
and divide(/).  Expressions are evaluated purely left-to-right - there is
no precedence.  So, 2+3*4 = 5*4 = 20, NOT 2+3*4 = 2+12 = 14.  There are no
parentheses.  Fractional values (with a decimal point) are allowed.

A word about units.  In the old version, a number without a unit would
be assigned a default unit of either inches (for most commands), points
(for font sizes), or none (for factors, such as mag).  This is still true
ONLY if there are no arithmetic operators or variable names.  If there
are operators (i.e., not a simple number any more), then there are *NO*
unit defaults.

An additional unit has been added... "no".  This means no unit.  It is not
normally necessary, as a number with no unit in a complex expression is
automatically dimensionless.  Care should be taken with arithmetic on
numbers.  For add and subtract, do not mix a number with a unit and a
number without.  It is fine to add 1in and 3cm, or subtract 2 from 4,
but adding 1 to 5pt is meaningless (1 what?).  For multiplication,
it is ok to mix the numbers, and it's ok to use two dimensionless
numbers, but be very careful if you use two numbers with units, since there
is no such thing as square units in this implementation.  So, you can
multiply 3in by 1.5, or divide 4 by 3, but don't multiply 3in by 2cm.
If you really need to do something like this, divide or multiply by the
unit, as in 3in/1in*2cm.  For division, you can divide a unit by a
non-unit, or divide a non-unit by another non-unit, or divide two units
(giving a unitless number) but don't divide a non-unit by a unit, as this
would give a unit in the denominator, which also is not supported.
You can divide two units, as in 3in/2cm, which gives the ratio of the two
distances.

Numbers and expressions can be entered into the text.  To do this, use
one of the various forms of the print command.  Note that this has changed
since the previous version of this documentation.  You used to be able to
simply put the expression in square brackets (or the current start and
end-command char), just like any other command or macro.  If the item in
the brackets was not recognized as a command, a font change, or a macro,
it was interpreted as an expression.  The expression was computed, and the
value was inserted into the text.  Note that this *DOES NOT* work any more!
You must use one of the 'print' commands.

A neat trick is to take a number with a unit, and divide by 1 of any unit
to get how many of that unit is in the number.  For example, if you wanted
to print the value of 3cm in inches, you could do "[print 3cm/1in] inches".
Likewise, the number of points in an inch is given by 1in/1pt.
Examples:
The sum of 1.3 and 2.4 is [print 1.3+2.4].
[define add "[print {1}+{2}]"]
The sum of 1.3 and 2.4 is [add 1.3 2.4].
[lm 1in+2cm]The left margin is [print 1in+2cm/1in] inches
or [print 1in+2cm/1cm] cm.

Constants and variables may be defined with the "set" command.  The first
argument is the constant or variable name, and the second argument is the
value.  Variables and constants can be used any place you use a number.
You can assign either a unit or non-unit value to a variable or a constant.
But you can't for example, assign 1 (no unit) to x then say "xpt" to get
1 point.  You could say "x*1pt" though.  Note that you can't call a macro
inside an expression, so in the circumference example below you can't just
say [circ 2in]/1in or something like that, so you have to assign the value
to a variable for later manipulation.

There are 10 variables, named x0, x1, through x9.  These are true temporary
variables, which may be redefined as often as necessary.  They have no value
until defined, and the definition is local to and valid in only the text
chain, i.e. you get a different set of variables for each text chain.
Variables can only hold numeric values, i.e. no text.  Variables are also
useful for counters, such as section numbers (if it's all in one text
chain).

Constants, on the other hand, are global and can be named anything, just
like macros.  They are good for setting up document-wide constants, such
as normal margin settings, margin settings for indented quotations, font
sizes for various kinds of text, etc.  If you change the value of a
constant, a requester pops up telling you it's changed and asking you to
reflow anything that uses the constant.  It will not automatically reflow.
If you don't do this, you may get strange results.  It (hopefully!) won't
crash, but the text definitely won't be formatted correctly.  The same
thing happens if you redefine a macro.  Macros are also global and should
not change.  Constants can only hold numeric values, i.e. not a font name.
Use macros for font names and other textual items.

Examples:
[set left .5in]
[lm left+1in]Testing...\n[lm left]More testing...
[set pi 3.14159,define circ "[set x3 2*pi*{1}]"]
The circumference of a 2 inch circle is [circ 2in,print x3/1in] inches.

Implemented commands as of 12-14-88:

The first section is grouped by functional areas.  The CS_ things label
the functional areas, and the CMD_ things show the actual commands.
For each command, the number of arguments (0, 1, 2, 1 or 2, or any number)
are also shown.

The second section lists the actual command names that can appear in the
text for each command.  There may be more than one text name for a given
command, for example "p", "pl", and "plain" are all valid.

These two sections are lifted directly from the source code, so it is
a complete list of commands.

#define CS_JUSTIFY         1
#define CMD_LJ             CS_JUSTIFY+0   |  ARG_0
#define CMD_RJ             CS_JUSTIFY+1   |  ARG_0
#define CMD_FJ             CS_JUSTIFY+2   |  ARG_0
#define CMD_CJ             CS_JUSTIFY+3   |  ARG_0
#define CMD_NOCJ           CS_JUSTIFY+4   |  ARG_0

#define CS_MARGIN          CS_JUSTIFY+5
#define CMD_LM             CS_MARGIN+0    |  ARG_1
#define CMD_RM             CS_MARGIN+1    |  ARG_1
#define CMD_TM             CS_MARGIN+2    |  ARG_1
#define CMD_BM             CS_MARGIN+3    |  ARG_1
#define CMD_INDENT         CS_MARGIN+4    |  ARG_1

#define CS_PARAMETER       CS_MARGIN+5
#define CMD_LEADING        CS_PARAMETER+0 |  ARG_1
#define CMD_SPACING        CS_PARAMETER+1 |  ARG_1
#define CMD_PARSPACE       CS_PARAMETER+2 |  ARG_1
#define CMD_SENTSPACE      CS_PARAMETER+3 |  ARG_1
#define CMD_SPACESTRETCH   CS_PARAMETER+4 |  ARG_1
#define CMD_AUTOTHRESH     CS_PARAMETER+5 |  ARG_1

#define CS_SKIPS           CS_PARAMETER+6
#define CMD_HSKIP          CS_SKIPS+0     |  ARG_1
#define CMD_VSKIP          CS_SKIPS+1     |  ARG_1
#define CMD_TABSET         CS_SKIPS+2     |  ARG_NOCHECK
#define CMD_TAB            CS_SKIPS+3     |  ARG_0
#define CMD_VCENTER        CS_SKIPS+4     |  ARG_0

#define CS_BREAK           CS_SKIPS+5
#define CMD_NOBREAK        CS_BREAK+0     |  ARG_0
#define CMD_BREAK          CS_BREAK+1     |  ARG_0
#define CMD_WIDOWON        CS_BREAK+2     |  ARG_0
#define CMD_WIDOWOFF       CS_BREAK+3     |  ARG_0
#define CMD_NEWPAGE        CS_BREAK+4     |  ARG_0
#define CMD_NEWCOLUMN      CS_BREAK+5     |  ARG_0

#define CS_MACRO           CS_BREAK+6
#define CMD_DEFINE         CS_MACRO+0     |  ARG_2
#define CMD_SET            CS_MACRO+1     |  ARG_2

#define CS_PRINT           CS_MACRO+2
#define CMD_PRINT          CS_PRINT+0     |  ARG_1

#define CS_SETCHAR         CS_PRINT+1
#define CMD_SETSTARTCHAR   CS_SETCHAR+0   |  ARG_1
#define CMD_SETENDCHAR     CS_SETCHAR+1   |  ARG_1
#define CMD_SETSHYPHCHAR   CS_SETCHAR+2   |  ARG_1
#define CMD_SETTABCHAR     CS_SETCHAR+3   |  ARG_1
#define CMD_SETTIECHAR     CS_SETCHAR+4   |  ARG_1
#define CMD_SETPSTARTCHAR  CS_SETCHAR+5   |  ARG_1
#define CMD_SETPENDCHAR    CS_SETCHAR+6   |  ARG_1

#define CS_MAGNIFY         CS_SETCHAR+7
#define CMD_MAG            CS_MAGNIFY+0   |  ARG_1
#define CMD_MAGX           CS_MAGNIFY+1   |  ARG_1
#define CMD_MAGY           CS_MAGNIFY+2   |  ARG_1

#define CS_STYLE           CS_MAGNIFY+3
#define CMD_BOLD           CS_STYLE+0     |  ARG_0
#define CMD_NOBOLD         CS_STYLE+1     |  ARG_0
#define CMD_ITALIC         CS_STYLE+2     |  ARG_0
#define CMD_NOITALIC       CS_STYLE+3     |  ARG_0
#define CMD_UNDERLINED     CS_STYLE+4     |  ARG_0
#define CMD_NOUNDERLINED   CS_STYLE+5     |  ARG_0
#define CMD_COMPRESS       CS_STYLE+6     |  ARG_0
#define CMD_NOCOMPRESS     CS_STYLE+7     |  ARG_0
#define CMD_PLAIN          CS_STYLE+8     |  ARG_0
#define CMD_DEFAULT        CS_STYLE+9     |  ARG_0

#define CS_FONT            CS_STYLE+10
#define CMD_FSIZE          CS_STYLE+0     |  ARG_1
#define CMD_FONT           CS_STYLE+1     |  ARG_1_2


struct symbol command_table[] = {
   {"autothresh",    CMD_AUTOTHRESH},
   {"bd",            CMD_BOLD},
   {"bm",            CMD_BM},
   {"bold",          CMD_BOLD},
   {"break",         CMD_BREAK},
   {"cj",            CMD_CJ},
   {"compress",      CMD_COMPRESS},
   {"def",           CMD_DEFINE},
   {"default",       CMD_DEFAULT},
   {"define",        CMD_DEFINE},
   {"fj",            CMD_FJ},
   {"font",          CMD_FONT},
   {"fsize",         CMD_FSIZE},
   {"hskip",         CMD_HSKIP},
   {"indent",        CMD_INDENT},
   {"it",            CMD_ITALIC},
   {"italic",        CMD_ITALIC},
   {"leading",       CMD_LEADING},
   {"lj",            CMD_LJ},
   {"lm",            CMD_LM},
   {"mag",           CMD_MAG},
   {"magx",          CMD_MAGX},
   {"magy",          CMD_MAGY},
   {"newcolumn",     CMD_NEWCOLUMN},
   {"newpage",       CMD_NEWPAGE},
   {"nobd",          CMD_NOBOLD},
   {"nobold",        CMD_NOBOLD},
   {"nobreak",       CMD_NOBREAK},
   {"nocj",          CMD_NOCJ},
   {"nocompress",    CMD_NOCOMPRESS},
   {"noit",          CMD_NOITALIC},
   {"noitalic",      CMD_NOITALIC},
   {"noun",          CMD_NOUNDERLINED},
   {"nounder",       CMD_NOUNDERLINED},
   {"nounderlined",  CMD_NOUNDERLINED},
   {"p",             CMD_PLAIN},
   {"parspace",      CMD_PARSPACE},
   {"pl",            CMD_PLAIN},
   {"plain",         CMD_PLAIN},
   {"print",         CMD_PRINT},
   {"rj",            CMD_RJ},
   {"rm",            CMD_RM},
   {"sentspace",     CMD_SENTSPACE},
   {"set",           CMD_SET},
   {"setendchar",    CMD_SETENDCHAR},
   {"setpendchar",   CMD_SETPENDCHAR},
   {"setpstartchar", CMD_SETPSTARTCHAR},
   {"setsofthyphenchar", CMD_SETSHYPHCHAR},
   {"setstartchar",  CMD_SETSTARTCHAR},
   {"settabchar",    CMD_SETTABCHAR},
   {"settiechar",    CMD_SETTIECHAR},
   {"spacestretch",  CMD_SPACESTRETCH},
   {"spacing",       CMD_SPACING},
   {"tab",           CMD_TAB},
   {"tabset",        CMD_TABSET},
   {"tm",            CMD_TM},
   {"un",            CMD_UNDERLINED},
   {"under",         CMD_UNDERLINED},
   {"underlined",    CMD_UNDERLINED},
   {"vcenter",       CMD_VCENTER},
   {"vskip",         CMD_VSKIP},
   {"widowoff",      CMD_WIDOWOFF},
   {"widowon",       CMD_WIDOWON}
};

I think the following are the new commands for 2.0.  I'm not sure, as some
of them were added long ago.  Check the list of commands against the 1.1
manual to be sure.

   {"autothresh",    CMD_AUTOTHRESH},        auto-hyphen threshhold value
   {"def",           CMD_DEFINE},            define a macro
   {"define",        CMD_DEFINE},            define a macro
   {"print",         CMD_PRINT},             print an expression
   {"set",           CMD_SET},               set a variable or constant
   {"setpendchar",   CMD_SETPENDCHAR},       set param reference start char
   {"setpstartchar", CMD_SETPSTARTCHAR},     set param ref end char

autothresh - sets the amount of extra white space to allow in a line
before auto-hyphening is tried.  Default is .5 in.  A small value tends to
hyphenate more lines.  A large value hyphenates less.  A value of 0 tries
to hyphenate every line, for which you can pay a significant performance
penalty (the autohyph routine takes a while to run).

Also, on hyphenation, another change.  You may now have more than one
softhyphen char (~ by default) in a word.  It uses the best softhyphen
char it can - the one that puts the most of the word on the previous line.
Under CD 1.1, it would always use the first softhyphen character.  Also,
if there are any softhyphens in a line, the word is not auto-hyphenated.

setpstartchar, setpendchar - the defaults for these are { }   they are
what's used to enclose parameter references in a macro definition.

There are also some reserved 'variables'.  They allow you to get the
current values of various settings, and also change most of them using
the 'set' command.  Most of them match the corresponding command.  For
these commands, doing (for example) [lm 5] is equivalent to doing
[set lm 5].  The exceptions are curx (current x position within the
object), cury (current y pos within the object), and page (current page
number).  The reserved variables are (again from the source code):

   {"bm",               RES_BM},
   {"curx",             RES_CURX},                 read-only
   {"cury",             RES_CURY},                 read-only
   {"fsize",            RES_FSIZE},                read-only
   {"indent",           RES_INDENT},
   {"leading",          RES_LEADING},
   {"lm",               RES_LM},
   {"magx",             RES_MAGX},
   {"magy",             RES_MAGY},
   {"page",             RES_PAGE},                 read-only
   {"parspace",         RES_PARSPACE},
   {"rm",               RES_RM},
   {"sentspace",        RES_SENTSPACE},
   {"spacestretch",     RES_SPACESTRETCH},
   {"spacing",          RES_SPACING},
   {"tm",               RES_TM},

Examples:
[set x0 lm;set lm 5]This has a large left margin.\n[lm x0]Back to before.

Yet to do
---------

Here's the things that I have yet to do:

Add greeking of text.

Add auto-flow around irregular graphics.

Change internal coordinate system (should only affect program internals)

Add autothresh to the list of reserved variables (it is not read-only).

Add some more "print" commands with various formatting types.

Add some kind of "if" command for conditionals.

Preliminary "if" commands (this may change):
[ifeq a b text1 text2]     if (a = b) use text1 else use text2
[ifne a b text1 text2]     if (a <> b) use text1 else use text2
[ifgt a b text1 text2]     if (a > b) use text1 else use text2
[ifge a b text1 text2]     if (a >= b) use text1 else use text2
[iflt a b text1 text2]     if (a < b) use text1 else use text2
[ifle a b text1 text2]     if (a <= b) use text1 else use text2

Text2 is optional in all cases.  Of course, the text could be a command,
which would be interpreted.

Example:
[ifeq lm 1 'lm is one' 'lm is [print lm;lm 1] and is now one']
[ifeq page/5*5 page "[print page]"]
               (prints the page number only if it's divisible by 5)

Preliminary "print" commands (this may change):
[print expr]         prints expr as integer if the number is an integer,
                     or with a decimal point if it's not an integer.
                     (this is currently implemented)
[printint expr]      prints as an integer (rounded)
[printint expr n]    prints as an integer using n columns (right-justified)
[printdol expr]      prints as a dollar amount (withOUT the dollar sign)
                     simply prints number with 2 decimal places (rounds)
[printdol expr n]    printdol using n columns (right-justified)
[printdec expr m]    prints expr with m decimal places (rounded).
[printdec expr m n]  prints expr with m decimal places using n columns
                     (like Fortran Fn.m)
[printrom expr]      prints expr as capital Roman numerals
[printromlc expr]    prints expr as lowercase Roman numerals

FEB 27, 1989 AW UPDATE
======================

All print commands have been added except printrom & printromlc
Everything mentioned above has been added except if commands.  Next
version will include the final if cmds and printrom cmds.

