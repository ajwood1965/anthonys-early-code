

#include "exec/types.h"
#include "intuition/intuition.h"
#include "graphics/gfxbase.h"
#include "graphed.h"
#include "desk.h"

flipget(screen,rp)
struct Screen *screen;
struct RastPort *rp;
{

struct IntuiMessage *mess,*GetMsg();
ULONG mclass;
USHORT mcode;
LONG Mx,My;
int temp1,rff;
USHORT *dataa,*datab;

static USHORT flipbData[] =
{

0xFFFF,0xFFFF,0xFFFF,0x8000,0x0080,0x0001,
0x8018,0x0080,0x8041,0x8076,0x0081,0x0021,
0x8191,0x0082,0x0011,0x8010,0x0084,0x0009,
0x8010,0x0088,0x0005,0x8010,0x009F,0xFFFF,
0x8010,0x0088,0x0005,0x8010,0x0084,0x0009,
0x8191,0x0082,0x0011,0x8076,0x0081,0x0021,
0x8018,0x0080,0x8041,0x8000,0x0080,0x0001,
0xFFFF,0xFFFF,0xFFFF,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0008,0x776F,0x726B,0x696E,0x672E,
0x2E2E,0x6E6C,0x792E,0x0A0A,0x2062,0x6520,
0x6672,0x6565,0x6C79,0x2064,0x6973,0x7472,
0x6962,0x7574,0x6564,0x2066,0x6F72,0x206E,
0x6F6E,0x2D70,0x726F,0x6669,0x740A,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0018,0x0000,0x0018,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x1806,0x0018,0x0060,0x0000,0x3600,
0x0000,0x1860,0x0000,0x0000,0x1800,0x0000,
0x1800,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x3E3E,0xEC66,0x3C3E,0x66EC,0x3C00,
0x7E00,0x7C3C,0x663C,0x0066,0x3C66,0x0063,
};
static struct BitMap flipb =
{
0,17,0,4,0,
/*48,32,1,     Width, Height, Depth */
0,
0,0,0,0,0,0,0
};

static USHORT flipaData[] =
{

0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,0xFFFF,
0x8000,0xC000,0x0000,0x0000,0xC000,0x0000,
0x0000,0x8000,0xC000,0x0780,0x0000,0xC001,
0x8000,0x3000,0x8000,0xC000,0x7B78,0x0000,
0xC006,0x0000,0x0C00,0x8000,0xC003,0x8307,
0x0000,0xC018,0x0000,0x0300,0x8000,0xC000,
0x0300,0x0000,0xC060,0x0000,0x00C0,0x8000,
0xC000,0x0300,0x0000,0xC180,0x0000,0x0030,
0x8000,0xC000,0x0300,0x0000,0xC3FF,0xFFFF,
0xFFF8,0x8000,0xC000,0x0300,0x0000,0xC180,
0x0000,0x0030,0x8000,0xC000,0x0300,0x0000,
0xC060,0x0000,0x00C0,0x8000,0xC003,0x8307,
0x0000,0xC018,0x0000,0x0300,0x8000,0xC000,
0x7B78,0x0000,0xC006,0x0000,0x0C00,0x8000,
0xC000,0x0780,0x0000,0xC001,0x8000,0x3000,
0x8000,0xC000,0x0000,0x0000,0xC000,0x0000,
0x0000,0x8000,0xFFFF,0xFFFF,0xFFFF,0xFFFF,
0xFFFF,0xFFFF,0x8000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
};
static struct BitMap flipa =
{
0,17,0,4,0,
/*97,31,1,     Width, Height, Depth */
0,
0,0,0,0,0,0,0
};


struct NewWindow flipWindow;
struct Window *flipwin;

flipWindow.Height = 15;
if (screen->Width > 400) {
   flipWindow.LeftEdge = 250;
   flipWindow.Width = 97;
   }
else {
   flipWindow.LeftEdge = 125;
   flipWindow.Width = 48;
   }
if (screen->Height <210)
   flipWindow.TopEdge = 175;
else
   flipWindow.TopEdge = 375;
flipWindow.DetailPen = 0;
flipWindow.BlockPen = 1;
flipWindow.Title = NULL;
flipWindow.Flags = ACTIVATE | RMBTRAP | SMART_REFRESH | BORDERLESS;
flipWindow.IDCMPFlags = MOUSEBUTTONS;
flipWindow.Type = CUSTOMSCREEN;
flipWindow.FirstGadget = NULL;
flipWindow.CheckMark = NULL;
flipWindow.Screen = screen;
flipWindow.BitMap = NULL;
flipWindow.MinWidth = 0;
flipWindow.MinHeight = 0;
flipWindow.MaxWidth = 640;
flipWindow.MaxHeight = 200;

flipwin = (struct Window *)OpenWindow(&flipWindow);

if (flipwin == NULL)
   exit(10);

flipa.BytesPerRow = RASSIZE(97,1);
flipb.BytesPerRow = RASSIZE(48,1);
dataa = AllocMem(RASSIZE(97,flipa.Rows),MEMF_CHIP);
movmem(&flipaData[0],dataa,RASSIZE(97,flipa.Rows));
flipa.Planes[0] = dataa;
flipa.Planes[1] = dataa;
flipa.Planes[2] = dataa;
flipa.Planes[3] = dataa;
datab = AllocMem(RASSIZE(48,flipb.Rows),MEMF_CHIP);
movmem(&flipbData[0],datab,RASSIZE(48,flipb.Rows));
flipb.Planes[0] = datab;
flipb.Planes[1] = datab;
flipb.Planes[2] = datab;
flipb.Planes[3] = datab;

if (screen->Width > 400)
   rp->BitMap = &flipa;
else
   rp->BitMap = &flipb;

ClipBlit (rp,0,0,flipwin->RPort,0,
      0,flipa.BytesPerRow * 8 ,flipa.Rows ,0xee,1,0);



ReportMouse(TRUE,flipwin);
ModifyIDCMP(flipwin, RAWKEY | MOUSEBUTTONS);

while (TRUE)  {
   Wait(1<<flipwin->UserPort->mp_SigBit);
   while((mess = GetMsg(flipwin->UserPort))!= 0) {

      mclass = mess->Class;
      mcode = mess->Code;
      Mx = mess->MouseX;
      My = mess->MouseY;
      ReplyMsg(mess);

      if (mclass == RAWKEY && 0x40 == (char) mcode ) {
         rff = -1;
         goto end1;
         }
      if (mclass == MOUSEBUTTONS && mcode == SELECTDOWN)  {
         temp1 = 48/2;
         if (screen->Width > 400)
            temp1 = 97/2;
         rff = 0;
         if (Mx <temp1)
            rff = 1;
         goto end1;
         }
      }
   }
end1:
CloseWindow(flipwin);
FreeMem(dataa,RASSIZE(97,flipa.Rows));
FreeMem(datab,RASSIZE(48,flipb.Rows));
return(rff);
}

