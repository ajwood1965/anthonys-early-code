#include "exec/types.h"
#include "exec/exec.h"
#include "intuition/intuition.h"
#include "graphics/text.h"
#include "graphics/gfx.h"
#include "graphics/rastport.h"
#include "stdio.h"
#include "desk.h"
#include "text.h"
#include "laser.h"
#include "/texted/texted.h"


COORD columnwidth;
COORD x_gridsize;
COORD y_gridsize;
COORD xoutlinespc;  /* space page outline is offseted from margins **/
COORD youtlinespc;  /* space page outline is offseted from margins **/
SHORT snaptogrid=FALSE;
SHORT displaygrid=FALSE;
SHORT displayguides=TRUE;
SHORT texterrors=TRUE;        /* TRUE means display text errors */
SHORT screensize;             /* actual screen height */
SHORT strip_spaces=TRUE;      /* strip multiple space on load */
SHORT double_newlines=FALSE;  /* 2 CR marks para end, else use 1 CR **/
SHORT dot_commands=FALSE;     /* interpret scribble dot commands **/
SHORT scribble_style=FALSE;   /* interpret scribble embeded commands */
SHORT wp_style=FALSE;         /* Input Text is from word perfect. */
SHORT snaptotop=FALSE;        /* start flowing at top */
SHORT autoflow=FALSE;         /* autoflow to next column */
SHORT ansi_escapes=TRUE;      /* Notepage style text load */
SHORT real_ascii=FALSE;       /* filter nonpritable ascii */
SHORT flow_warnings=TRUE;     /* Warn when not finished flowing */
SHORT usedefault = TRUE;      /* Reflow uses default, not same */
SHORT time_for_same = FALSE;  /* Set when we want flow to use same */
SHORT do_trans = TRUE;        /* turns on and off translation */
SHORT std_height;             /* non interlaced screen height */
SHORT std_width;              /* screen width, typicly 640 */
SHORT greeking = FALSE;       /* fake output text. */
SHORT pointer_mode = PTR_NORMAL;
SHORT autohyphenate = FALSE;  /* Hyphenate words while flowing? */
SHORT default_mag = 1;        /* default magnification for new pages */
SHORT irregular = FALSE;      /* irregular flow around graphics? */
UBYTE *translate;             /* points to translation table */
struct object *last_picked=0;   /* point to last object picked when linking */
char default_font_name[40];   /* Just what it says. */
char default_cmd_list[256]=""; /* embeded cmds to execute before each flow */

struct pageinfo   page[MAXPAGES];
struct text_state defaultstate;
struct text_state samestate;     /* set by reflowchain, sometimes */
struct pageinfo   defaultpage;
struct rule       defaultrule={0xFFFF,8,0};
struct object     default_object;
struct Window     *clipboard;
struct laserfont  *firstlaserfont;
struct printerprefs printerprefs;
struct Window *canwin;   /** window used to display cancel msg on print **/
struct Window *coord_window;   /** used in displaying mouse coordinates **/
struct Screen *screen;         /** City Desk main screen **/
APTR  temp_ptr;                /** CB's old pr_WindowPtr to be restored **/

COORD xshadowsize;       /** size in coord's of shadow **/
COORD yshadowsize;       /** size in coord's of shadow **/
ULONG xpix;
ULONG ypix;
UWORD xinch,yinch;
FIXED cpertextpixx,cpertextpixy;
char printername[60];
char *pname;

void main(argc,argv)
int argc;
char *argv[];
{
extern struct Menu Titles[];
void settypeflag();
char *text,*text2,*texttoflow;
char buffer[81];
ULONG class;
USHORT code;
SHORT mousex,mousey;
SHORT menunum,itemnum,subnum;
SHORT openworkbench = FALSE;
COORD x,y;
int pg;      /* current page being displayed */
short lastpg;
int i;
SHORT j,toggle=0;
SHORT type;
SHORT xoff,yoff;
SHORT mode=0,alttool,oldmode;
LONG hpot,vpot;
LONG oldmag,newmag;
SHORT nice=FALSE;   /** graphic resize nice or anyway? **/
SHORT sizedir=0;   /** resize direction Xonly , Yonly, or ANYWAY **/
LONG len;
SHORT loadautoprefs; /** TRUE if autoprefs file was present on load **/
int status;
COORD x_left, x_right;     /** DELETE ME!! **/

struct object *prevobj();
struct pageview *view;
struct PropInfo *pi;
struct MenuItem *ItemAddress();
struct IntuiMessage *message,*GetMsg();
struct Window *toolbox,*opentoolbox(),*thiswindow;
struct graphic *graphic;
struct object *obj,*objcopy,*flowobj,*obj_a;
struct object *flowtext(),*reflowchain();
struct object tempobj;
struct text_object *to;
struct object *createobject(),*matchrange();
struct viewmsg msg;
struct Node *node;
struct click *click,*getclick();
struct macro_text *mt;

openlibraries();

texttoflow=NULL;     /** get rid of compiler warning **/
flowobj=NULL;        /** get rid of compiler warning **/
coord_window = 0;    /** coordinate display not active **/

canwin=0;          /** So calls to checkcan() know we are not printing ***/
firstlaserfont=0;  /** No laserfonts loaded yet **/
pg=1;   /* starting page number */
lastpg = 1;
default_object.dpi = 75;
default_object.data = (APTR)&defaultrule;
default_object.type = RULE;
default_object.density = 0;

/** initilize all pages **/

for (i=0;i<MAXPAGES;i++) {
   NewList(&page[i].objects.lh_Head);
   page[i].view=NULL;
   page[i].pn=i;              /* set page number */
   page[i].flags = 0;
   }

ghost_save();          /** ghost save.. option in project menu **/
init_fonts();          /** initialize the available fonts chain **/

/** try and load autoprefs & loadfonts **/

screensize = get_screen_data();

if (loadprefs("AUTOPREFS",TRUE)==AOK) {
   loadautoprefs=TRUE;
   }

else {
   loadautoprefs=FALSE;
   }

if (argc > 1) {      /**!!!!!!! take this out?? **/
   std_height = 800;
   std_width = 1008;
   screensize = std_height;
   }

if (screensize >= 800 && AvailMem(MEMF_CHIP) < 400000)
   openworkbench = CloseWorkBench();

screen=(struct Screen *)openscreen(std_width,screensize,2);
if (screen==0) {
   telluser2(0,"Can't open screen!","",FALSE);
   close_fonts();
   closelibraries();
   exit(10);
   }


/** set up clipboard **/

if (createview(screen,&page[CB])!=AOK) {
   CloseScreen(screen);
   telluser2(0,"Can't open clipboard!","",FALSE);
   close_fonts();
   closelibraries();
   exit(10);
   }

msg.page=&page[CB];
msg.command=REFRESH;
viewmonitor(&msg);

/***** open the tool box ****/

toolbox=opentoolbox(screen,page[CB].view->window->UserPort);

newpointer(screen, BUSY);

if (!loadautoprefs) {  /** if no autoprefs, make smart printer choice **/

   printerprefs.printertype=PREFERENCES;
   if (loadfonts(screen)!=AOK) {  /** find what preferences printer **/
      newpointer(screen, NORMAL);
      CloseScreen(screen);
      close_fonts();
      closelibraries();
      exit(10);
      }

   initdefaultstate();     /** initilize default text state **/

   if (printername[0]=='H' && printername[1]=='P' && printername[2]=='_') {
      printerprefs.printertype=HPLASER;
      strcpy(default_font_name, "courier");
      }

   if (loadfonts(screen)!=AOK) {
      CloseScreen(screen);
      close_fonts();
      closelibraries();
      exit(10);
      }
   setdeffont(screen);  /** sets font ptr in default state from ***/
                        /** name in default_font_name **/
   settypeflag();          /** set xinch, yinch **/
   initdefaultstate2();    /** reset stuff dependent on xinch, yinch **/
   initdefaultpage();      /** initilize old default page structure **/

   copypage(&defaultpage,&page[DEFAULTEVEN]);
   copypage(&defaultpage,&page[DEFAULTODD]);
   copypage(&defaultpage,&page[CUTPAGE]);
   copypage(&defaultpage,&page[CB]);   /* Clip Board opened when we start */

   x_gridsize = xinch/2;
   y_gridsize = yinch/2;
   }

settypeflag();          /** check submenu and set cpertextpix **/
initdefaultpage();      /** initilize old default page structure **/

if (printerprefs.printertype==HPLASER)
   hp_font_setup("autofonts");      /** try and download hp fonts **/

/**** set up this page ****/

check_page(1); /** use default page **/

if (createview(screen,&page[pg])!=AOK) {
   CloseScreen(screen);
   telluser2(0,"Can't open page1","",FALSE);
   close_fonts();
   closelibraries();
   exit(10);
   }

newpointer(screen, BUSY);

if (autohyphenate) {
   if (load_patterns("hyphen.tex")!=AOK)
      autohyphenate=FALSE;
   }

load_macros("automacros"); /** load macros if they are there **/

msg.page=&page[pg];
msg.command=REFRESH;
viewmonitor(&msg);

setonoff();             /** set preferences submenu checkmarks **/
setmenus(screen, TRUE);  /* turn on menus */
xshadowsize = SHADOWSIZE*xinch/576;
yshadowsize = SHADOWSIZE*yinch/576;
xoutlinespc = 75*xinch/576;
youtlinespc = 75*yinch/576;
newpointer(screen, NORMAL);

/* printf
