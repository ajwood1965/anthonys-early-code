#include <exec/types.h>
#include <exec/exec.h>
#include <libraries/dos.h>
#include <devices/audio.h>
#include <intuition/intuition.h>
#include "/include/psound.h"

extern struct studioBase *studioBase;
struct Module *thismod;

short se_play_sample;
short se_io_ready_for_data;
short se_io_chan_done;
short se_kill_module;
short se_io_begin_playing;
short se_io_stop_playing;
short se_io_play_data;
short se_stop_chan;
short se_record_sample;
short se_stop_recording;
short se_io_begin_recording;
short se_io_stop_recording;
short se_io_record_data;

static struct VirtualChan {
	unsigned long data_index;
	unsigned long data_start;
	unsigned long data_len;
	struct Disk_Samp *playing_samp;
	USHORT bigblockptr;
	int fp;
	struct EditInstance *ei;		/** !!!!! OBSOLETE!!! ****/
	int oldindex;
	} vc[4];

void msg_ready_for_data();
void FreeChan();
void InitModDiskIO();
void play();
void handle_studioevents();
void telluser();
void msg_chan_done();
void stop_playing();
void stop_record_sound();

/***********************************************************/

void main()
{
openlibraries();
InitModDiskIO();

while (TRUE) {
   Wait(1<<thismod->notifyme->mp_SigBit);
	handle_studioevents();
	}
}

/***********************************************************/

void InitModDiskIO()
{
static struct NewModule mod_data ={"DiskIO",0};

if ((thismod=(struct Module *)AddModule(&mod_data))==0) {
   telluser("Can't add mod_diskio","");
	closelibraries();
   exit(10);
   }

/** Turn on the events we want to hear about **/

se_play_sample			=GetEventID("SE_PLAY_SAMPLE");
se_io_ready_for_data	=GetEventID("SE_IO_READY_FOR_DATA");
se_io_chan_done		=GetEventID("SE_IO_CHAN_DONE");
se_kill_module			=GetEventID("SE_KILL_MODULE");
se_io_begin_playing	=GetEventID("SE_IO_BEGIN_PLAYING");
se_io_stop_playing	=GetEventID("SE_IO_STOP_PLAYING");
se_io_play_data		=GetEventID("SE_IO_PLAY_DATA");
se_stop_chan			=GetEventID("SE_STOP_CHAN");
se_record_sample		=GetEventID("SE_RECORD_SAMPLE");
se_stop_recording		=GetEventID("SE_STOP_RECORDING");
se_io_begin_recording=GetEventID("SE_IO_BEGIN_RECORDING");
se_io_stop_recording	=GetEventID("SE_IO_STOP_RECORDING");
se_io_record_data		=GetEventID("SE_IO_RECORD_DATA");		

NotifyMeOnEvent(se_play_sample, thismod);
NotifyMeOnEvent(se_io_ready_for_data, thismod);
NotifyMeOnEvent(se_io_chan_done, thismod);
NotifyMeOnEvent(se_kill_module, thismod);
NotifyMeOnEvent(se_stop_chan, thismod);
NotifyMeOnEvent(se_io_record_data, thismod);
NotifyMeOnEvent(se_record_sample, thismod);
NotifyMeOnEvent(se_stop_recording, thismod);
}

/***********************************************************/

void handle_studioevents()
{
struct StudioEvent *event;

while ((event=(struct StudioEvent *)GetMsg(thismod->notifyme))!=0) {

		if (event->type==se_play_sample) {
			play(event->arg1, event->arg2, event->arg3);
			}

		else if (event->type==se_stop_chan) {
			stop_playing(event->arg1);
			}

		else if (event->type==se_kill_module && (struct Module *)event->arg1==thismod) {
			ReplyMsg(event);			/** need because of exit **/
			DeleteModule(thismod);
			closelibraries();
			exit(0);
			}

		else if (event->type==se_io_ready_for_data) {
			msg_ready_for_data(event,0);
			}

		else if (event->type==se_io_chan_done) {
			msg_chan_done(event);
			}
		
		else if (event->type==se_io_record_data) {
			msg_record_data(event);
			}

		else if (event->type==se_record_sample) {
			record_sound(event->arg1, event->arg2);	/* name, rate */
			}

		else if (event->type==se_stop_recording) {
			stop_record_sound();
			}
	ReplyMsg(event);
	}
}

/***********************************/
/* Play a digitized sample         */
/***********************************/

void play(samp,start,len)
int len,start;
struct Disk_Samp *samp;

{
struct MsgPort *CreatePort();
int unit_num;

/*printf("play: %s start %d len %d\n",samp->name,start,len);*/

unit_num = AllocChan();
if (unit_num==-1)
	return;						/** ADD ERROR CODES!!!! ***/

/** PUT IN ERROR DETECTION STUFF ***/

vc[unit_num].data_index = start;
vc[unit_num].data_start = start;
vc[unit_num].data_len = len;
vc[unit_num].playing_samp = samp;
vc[unit_num].fp = ReadLockSamp(samp);
vc[unit_num].ei = 0;

Seek(vc[unit_num].fp,start,OFFSET_BEGINNING);
QuickRead(vc[unit_num].fp, studioBase->bigblock[0][unit_num]);
vc[unit_num].bigblockptr=0;
msg_ready_for_data(0,unit_num);
BroadcastEventParms(se_io_begin_playing,unit_num,samp->rate,64,len,0,0);
}

/*******************************************************/
/*** cancel a playing channel 								**/
/*******************************************************/

void stop_playing(unit_num)
int unit_num;
{
if (vc[unit_num].playing_samp) {
	BroadcastEventParms(se_io_stop_playing,unit_num,0,0,0,0,0);
	ReadUnLockSamp(vc[unit_num].playing_samp,vc[unit_num].fp);
	vc[unit_num].playing_samp=0;
	}
}


/*********************************************************/
/*** called every time there is a SE_IO_READY_FOR_DATA ***/
/*********************************************************/

void msg_ready_for_data(msgtorep,chan)
struct StudioEvent *msgtorep;
int chan;
{
int blklen;
int unit_num;
unsigned long last_block;

/*printf("Ready 4 Data");*/


if(msgtorep) {
	unit_num=msgtorep->arg1;
	if (vc[unit_num].playing_samp==0)
		return;
 	/*printf("MESSAGE\n");*/
	}
else {
	unit_num=chan;
	/*printf("Start\n");*/
	}

vc[unit_num].data_index=vc[unit_num].data_index+BIG_BLOCK_SIZE;

if (vc[unit_num].data_index >= (vc[unit_num].data_start+vc[unit_num].data_len)) {
   last_block = LAST_BLOCK;
   blklen = vc[unit_num].data_start + vc[unit_num].data_len - (vc[unit_num].data_index - BIG_BLOCK_SIZE);
	ReadUnLockSamp(vc[unit_num].playing_samp,vc[unit_num].fp);
   }
else {
   last_block = 0;
   blklen = BIG_BLOCK_SIZE;
   }

BroadcastEventParms(se_io_play_data, studioBase->bigblock[vc[unit_num].bigblockptr][unit_num], blklen, unit_num, 0, 0, last_block);

vc[unit_num].bigblockptr=(vc[unit_num].bigblockptr+1)&1;

if (last_block!=LAST_BLOCK) {
   QuickRead(vc[unit_num].fp,studioBase->bigblock[vc[unit_num].bigblockptr][unit_num]);
	}
}

/**************************************************************/

void msg_chan_done(msg)
struct StudioEvent *msg;
{
vc[msg->arg1].playing_samp=0;
FreeChan(msg->arg1);
}

/**************************************************************/

/** Handle channel allocation/ deallocations **/

static ChansInUse = 0;

int AllocChan()
{
short i;
short ChanBit;

for (i=0; i < 4 ; i++)	{
	ChanBit=(1<<i);
	if ((ChansInUse&ChanBit)==0) {		/** Free chanel !! **/
		ChansInUse |= ChanBit;
		return((int)i);
		}
	}
return(-1);
}

/**************************************************************/

void FreeChan(ChanNum)
int ChanNum;
{
ChansInUse &= (~(1<<ChanNum));
}

/**************************************************************/

void debug_samp_print(s)
struct Disk_Samp *s;
{
printf("Debug Print: samp %x '%s'\n",s,s->name);
printf("wfp %x rfp0 %x\n",s->wfp,s->rfp[0]);
printf("len %d rate %d type %d flags %x\n",s->length,s->rate,s->type,s->flags);
printf("version %d\n",s->version);
}
/**************************************************************/

/***!!!!!! CHANGE THIS!!! **/

void telluser(l1,l2)
char *l1,*l2;
{
if (l1)
	printf(l1);
if (l2)
	printf(l2);
}

