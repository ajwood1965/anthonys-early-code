[PRELIMINARY: INFO IN TRANSIT]

Studio 16
=========

Introduction

Studio 16 is an environment for manipulating 16 bit digital sounds.  It
consists of "studio.library", an Amiga sharable library, various "modules"
(like the editor and meters) as well as a protocol for the passing of
messages.  To a lesser extent, studio 16 also includes a custom gadget
library.  However, use of these gadgets are optional. You can use standard
Amiga gadgets in your modules if you choose.

This document is intended to be a tutorial to the Studio 16 environment.
While reading this tutorial it will be helpful (required, actually) to
refer to studio16.h for structure info and studio.doc (autodoc reference
for all studio.library calls.)

Modules
=======

In studio 16 parlance, a "module" refers to any amiga program designed to
run as its own task and communicate with the studio.library.  For example,
each of the standard modules included with studio 16 (mixer, editor,
meters, etc.) were written as stand alone lattice 'C' programs.  One of the
first things they do is open "studio.library" then call 

struct NewModule newmodulestruct = {"my_new_module",0};
AddModule(&newmodulestruct);

This call registers the module with the library.  The module can then make
additional calls, as discussed below.

studio.library
==============

Studio 16 functions can be divided up into two basic types: those used to
manipulate samples and those used to pass messages.

The Message Switch
==================

Studio.library can be thought of as a message switch.  Modules broadcast
messages to the library, and the library switches the messages to other
modules.  By sending and receiving messages (also referred to as "events")
modules send commands and information to each other.  For example, to play
a sample you could use code like this:

SimplePlayFunc(sample)
struct Disk_Samp *sample;
{
short se_play_sample;

se_play_sample = GetEventID("SE_PLAY_SAMPLE");
BroadcastEventParms(se_play_sample, sample, 0, 0, 0, 0, 0);
}
 
A Disk_Samp struct is what studio.library uses to refer to a particular
sample, already recoarded and usually on disk.  All events have an ASCII name
(such as "SE_PLAY_SAMPLE")  However, studio.library uses an short integer
to refer to them.  This "ID" is allocated at run time by the call to
GetEventID().  

GetEventID() takes a string of text (any string) an looks it up in a
table of event names.  If the name is found, the appropriate
"ID" is returned.  However, if the name is not found, a new entry is created and a
new ID is returned.  This system allows new event's to be added at any
time.  The only requirement is that the event name does not conflict with
an existing event name.  IDS are allocated starting at 0 and moving
upward.  The number of IDS can be found in studioBase->max_registered_ids.
Thus the highest allocated ID is studioBase->max_registered_ids-1;

The BroadcastEventParms() call above is Asynchronous (It returns
immediately.)  BroadcastEventParms() sends a copy of the event to every
module who is listening for a "SE_PLAY_SAMPLE" message. 

In the case of SE_PLAY_SAMPLE, there will probably only be one module
listening (DiskIO) who's job is to take PLAY events and startup the actual
playing.  However, events like SE_SET_SAMPLING_RATE are monitored by all
modules that have a sampling rate slider. This way anyone in the system can
change the sampling rate and all modules update their sliders accordingly.

Requesting Events
=================

For a module to receive events it must turn them on:

NotifyMeOnEvent(thismodule, event_id);

To quit receiving events use:

IgnoreEvents(thismodule, event_id);

Simple Module
=============

Here's a very simple studio 16 module.  All it does
is open the library and wait for an SE_KILL_MODULE event.  This
module is basically the smallest legal studio 16 module.

#include "exec/types.h"
#include "exec/exec.h"
#include "/include/studio16.h"

struct studioBase *studioBase;

void main()

{
static struct NewModule mod_data ={"SimpleModule",0};
struct Module *thismod;
struct StudioEvent *event;
short se_kill_module;

studioBase=(struct StudioBase *)OpenLibrary("studio.library",0);
if (studioBase==NULL) {
 exit(10);
 }

if ((thismod=(struct Module *)AddModule(&mod_data))==0) {
 CloseLibrary(studioBase);
   exit(10);
   }

se_kill_module=GetEventID("SE_KILL_MODULE");
NotifyMeOnEvent(se_kill_module, thismod);

Wait(1<<thismod->notifyme->mp_SigBit);
while ((event=(struct StudioEvent *)GetMsg(thismod->notifyme))!=0) {
 if (event->type==se_kill_module && (struct Module *)event->arg1==thismod) {
  ReplyMsg(event);
  DeleteModule(thismod);
  CloseLibrary(studioBase);
  exit(0);
  }
 }
}

Run by itself SimpleModule will hang up.  But you can run it in
conjunction with the other standard studio 16 modules and it will quit when
you close down the other modules.  You can also run dp (debug print) when
SimpleModule is running to verify that its really there.

For more complete examples, see the enclosed source code for openlist.c

For a complete list of currently defined studio 16 messages see events.doc.
Note that you are free to define your own messages, as long as your names
don't conflict with the list of "official" messages.  If you plan on
releasing commercial (or event PD) modules, you should register your event
names with SunRize so they can be put in events.doc.  If you don't, you
risk possible naming collisions with future modules.

Channels and AudioHandlers
==========================

To studio 16, a "channel" refers to a hardware path for audio to be
recorded or played on.  For example, the Amiga has four 8 bit playback
"channels." Each playback channel can play a sound relatively independent of 
the other channels. The sampling rate and number of bits of a channel
may or may not be independent of the other channels on the same piece
of hardware.  For example, the Amiga has four 8 bit channels that can each
have their own playback rate.  The AD1012 12 bit card has 4 "virtual"
channels that must all have the same sampling rate.  Virtual refers to the
fact that the channels are simulated by the DSP and don't actually exist as
separate D/A converters.

An "AudioHandler" is a studio 16 module designed to handle the device
specific interface between audio hardware and studio 16.  AudioHandlers are
device drivers for audio cards.  All AudioHandlers receive and transmit a
standard set of events.  These events are used to pass the playback and
record data to/from "DiskIO".  DiskIO's job is to record or playback data
from the hard disk.

Studio 16 comes with an AudioHandler for the Amiga's internal sounds. The
AD1012 comes with an AudioHandler to communicate with the AD1012 and of
course the AD1016 includes a handler specific to itself.

It can be seen that in order to fully specify where a sound plays, you
must specify a Channel and an AudioHandler.  Together, these two pieces of
information form a "ChanKey:"

struct ChanKey *key;   /** see studio16.h **/
key=AllocChan(NULL,-1);  /** AudioHandler, channel number **/

This code would allocate the next available channel on the next available
AudioHandler.  It is common for multiple handlers to be resident at the
same time.  For example, if you had two AD1012 cards plugged into your
system you may have three AudioHandlers loaded. The Amiga's internal sound
handler, and a handler for each of the two AD1012 cards.

Each AudioHandler has a "priority" (different from it's module's task
priority) that specifies the order handlers are searched for channels to
Allocate.  For example, the amiga's handler has a priority of -10. AD1012
has a priority of 0. If you used AllocChan(NULL, -1); to allocate channels,
The fifth call would allocate an internal sound channel.  The first four
would all be AD1012 channels.  You can get around this by specifying a
pointer to an AudioHandler in the call to AllocChan.  Use
FindAudioHandler() to get this pointer, or traverse the studioBase audio
handler list.

Sample Manipulation
===================

[SUPERPRELIMINARY: INFO UNDER CONSTRUCTION]

Studio 16 working samples are maintained on AmigaDos devices,
generally a hard disk.  To manipulate samples, studio 16 modules
use a set of fairly low level calls.  All samples are referenced
by a pointer to a Disk_Samp struct .  This pointer originally comes
from a call to CreateSample.  For example:

struct Disk_Samp *samp;
CreateSample("ANewSample",0,&samp);

Note that the third parameter is pointer to a pointer.

Once a sample has been "created" you must get a read or write "lock" on the
sample in order to access it.  This done with calls to ReadLockSamp() and
WriteLockSamp().  A Disk_Samp (i'll refer to it as just "sample") can have
multiple read locks from multiple modules, but only one module may write
lock a sample at a time.  Once you have a lock, you use commands like
QuickRead(), QuickWrite(), and QuickCopy() to access the sample's data.

To manipulate samples, studio 16 includes the following functions:

int CreateSample(name, version, ptrptr)
int  CloseSample(ptr)
short GetOneSample(fp, i)
void  SetSampLength(ptr,fp)
int  ReadLockSamp(ptr)
void  ReadUnLockSamp(ptr, fp)
int  QuickWrite(ptr,data,len)
int  QuickRead(fp,data)
int  QuickCopy(tofp, fromfp, len)
int  WriteLockSamp(ptr)
void  WriteUnLockSamp(ptr)

