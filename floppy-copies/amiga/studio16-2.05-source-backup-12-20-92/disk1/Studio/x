(studio.c)		AddAudioHandler
----------------------------------------------------------------------------
NAME
	AddAudioHandler -
SYNOPSIS
	
	struct AudioHandler *AddAudioHandler(nh)
	
	struct NewAudioHandler *nh;
FUNCTION
	Given a NewAudioHandler struct, this function creates a new
	entry in the StudioBase->handlers List.  This funciton should
	be called by any Module who's job is to be a device driver
	for an audio card designed to be used by studio 16.

	Note that name's pointer is copied but not its text.  Therefore,
	the name's text should be declared static by the module 
	initilizing NewAudioHandler.	This is in contrast to other
	studio 16 functions like AddModule() which make a copy of the
	text.
INPUTS
	pointer to NewAudioHandler struct (see studio.h)
RESULTS
	pointer to AudioHandler struct or NULL if not enough memory
----------------------------------------------------------------------------
(ff.c)		AddFileFilter
----------------------------------------------------------------------------
NAME
	AddFileFilter -
SYNOPSIS
	
	struct FileFilter *AddFileFilter(nff)
	struct NewFileFilter *nff;
FUNCTION
	Adds a new file filter to studio 16.  File filters are used
	when accessing a samples data.  Usually via SampleOpen().
INPUTS
	NewFileFilter struct *
RESULTS
	NULL or pointer to FileFilter if everything went ok
----------------------------------------------------------------------------
(module.c)		AddModState
----------------------------------------------------------------------------
NAME
	AddModState -
SYNOPSIS
	
	struct StandardModState *AddModState(state_size,name,instname)
	char *name;
	char *instname;
	int state_size;

FUNCTION
	Allocates a new Mod State structure & links it into StudioBase
	
INPUTS
	state_size	size of state struct to alloc
	name			name of module or NULL for no name
	instname		name of this instance or NULL to generate default
RESULTS
	NONE
----------------------------------------------------------------------------
(module.c)		AddModule
----------------------------------------------------------------------------
NAME
	AddModule -
SYNOPSIS
	
	struct Module *AddModule(nm)
	struct NewModule *nm;
FUNCTION
	Allocate memory for a new module struct and links it into the
	StudioBase->modules chain.	 All data from NewModule is
	copied, including the name, so that NewModule may be
	discarded. A port is also allocated to recieve broadcasted
	messsages (module->notifyme).	 The Module's ModState struct
	is also allocated and zeroed based on the passed size.
INPUTS
	pointer to module struct
RESULTS
	NONE
----------------------------------------------------------------------------
(regions.c)		AddRegionBySfp
----------------------------------------------------------------------------
NAME
	AddRegionBySfp
SYNOPSIS
	
	int AddRegionBySfp(sfp, region)
	struct SampleFilePointer *sfp;
	struct Region *region;

FUNCTION
	Given a pointer to an Open Sample, this function will 
	add a new region entry.
INPUTS
	sfp			Indicates which sample to add to
	regin			Copies this information into a free region entry
					in sfp->tag.dregions.
RESULTS
	standard error code
----------------------------------------------------------------------------
(smpte.c)		AddSmpteSink
----------------------------------------------------------------------------
NAME
	AddSmpteSink
SYNOPSIS
	
	struct SmpteSink *AddSmpteSink(ns)
	struct NewSmpteSink *ns;
FUNCTION
	Adds a Smpte Sink into the sink chain, it uses a priority to decide
	where in the chain it should go.
INPUTS
	ns - NewSmpteSink structure
RESULTS
	a pointer to the created SmpteSink structure.
----------------------------------------------------------------------------
(smpte.c)		AddSmpteSource
----------------------------------------------------------------------------
NAME
	AddSmpteSource
SYNOPSIS
	
	struct SmpteSource *AddSmpteSource(ns)
	struct NewSmpteSource *ns;
FUNCTION
	Adds a Smpte Source into the source chain. The new source becomes
	the active one. This function also lanches the 
	task, "STUDIO_SMPTE_TIMEOUT" that is used to determine whether
	or not a smpte timeout has occured.
INPUTS
	ns - NewSmpteSource structure
RESULTS
	a pointer to the created SmpteSource structure.
----------------------------------------------------------------------------
(studio.c)		AllocChan
----------------------------------------------------------------------------
NAME
	AllocChan -
SYNOPSIS
	
	struct ChanKey *AllocChan(ah, cn, flags)
	struct AudioHandler *ah;	/** audio handler or NULL for any */
	int cn;		/** channel number or -1 for any **/					
	unsigned long flags;

FUNCTION
	Allocate an audio channel for future use.	 This can be a
	record, playback, monitor, or output channel.

	Flags:
	Any of the CK_ flags are useable.
	multiple flags are used both qualifiers must be true.

	CK_CHAN_PLAY	A playback channel (eg. Four on the AD1012)
	CK_CHAN_RECORD A record channel	 (eg. One on the AD1012)
	CK_CHAN_OUTPUT Allocate the output jack as a record
						channel.	 This allow's you to record the four
						channel mix, or record the ouput of an effect
						that is attached to an output channel.
	CK_CHAN_MONITOR Allocate the "monitor" channel.	 This isn't
						 an actual channel.	By allocating the "monitor"
						 you can adjust monitor volume levels, etc.
	CK_ID_ONLY		 This means that you don't want to actually
						 allocate a resource.  Instead, you want to
						 Generate a ChanKey that ID's a particual
						 channel.  For example, if you want to send
						 SE_SET_CHANNEL_VOLUME commands, you will
						 need to specify a chan key as an argument.
						 You should use CK_ID_ONLY when allocating the
						 key as you don't want the resources, just an
						 identifier. NOTE: If you allocate a channel
						 ID_ONLY you DO NOT need to FREE it.
	CK_CHAN_PLAY|CK_CHAN_PAN	A playback channel which is panable.


INPUTS
	Audio handler pointer (NULL for default) or
	Channel number (-1 for any)
	flags indicating channel type wanted
RESULTS
	struct ChanKey *.	 You must remember this pointer since
		you will need it to FreeChan(), unless you allocated 
		the channel ID_ONLY.


VVVV NOT TRUE!! VVVV
(You must remember the actual pointer. You can't regenerate it later by 
	Allocating your own ChanKey and filling in it's elements.)
----------------------------------------------------------------------------
(studio.c)		AllocChanByKey
----------------------------------------------------------------------------
NAME
	AllocChanByKey -
SYNOPSIS
	struct ChanKey *AllocChanByKey(ck)
	struct ChanKey *ck;

FUNCTION
	Allocate an audio channel for Exclusive use.	 This can be a
	record, playback, monitor (input), or output channel. This
	function simply sets the CK_CHAN_IN_USE flag;

INPUTS
	struct ChanKey *.	This is a pointer to the ChanKey that
				you want to allocate, commonly got from
				a menu.
RESULTS
	struct ChanKey *.	 You must remember this pointer since
	you will need it to FreeChan().
----------------------------------------------------------------------------
(samples.c)		AllocCompletePath
----------------------------------------------------------------------------
NAME
	AllocCompletePath
SYNOPSIS
	
	char *AllocCompletePath(path, name)
	char *path;
	char *name;
FUNCTION
	Given a path and name pointer, this function will combine
	them into a complete path.  New memory is alloced using
	Exec AllocMem() to hold the complete path.  The callre
	of this functions is responsable for freeing the memory
	when finished witht the complete path.
INPUTS
	path	pointer to path.  E.G "DH1:Project1"
	name	pointer to a name (NULL okay.)  E.G "Bang"
RESULTS
	pointer to new complete path.  E.G "DH1:Project1/Bang"
----------------------------------------------------------------------------
(asio.c)		ASClose
----------------------------------------------------------------------------
NAME
	ASClose
SYNOPSIS
	
	
	int ASClose(as)
	struct ActiveSample *as;
FUNCTION
	Frees an ActiveSample struct and its buffers.  Also closes
	the associated file.
INPUTS
	ActiveSample struct
RESULTS
	zero if no error
----------------------------------------------------------------------------
(asio.c)		ASCountBlocks
----------------------------------------------------------------------------
NAME
	ASCountBlocks
SYNOPSIS
	
	int ASCountBlocks(as, flags)
	struct ActiveSample *as;
	unsigned long flags;
FUNCTION
	Counts the number of indicated big blocks.  For example, if
	you have triggered a sound, waited for it to finish, and
	you want to rewind and trigger it again, you could use:

		ASWaitStop(as);
		ASFlush(as, 0);	** probably not needed **
		ASSeek(as, 0, ASS_OFFSET_BEGINNNING);
		k=ASCountBlocks(as, ASCB_EMPTY_BLOCKS);
		while (k--)
			ASRead(as);
		ASTrigger(as);

INPUTS
	as		ActiveSample pointer
	flags Type of blocks to count: 
		ASCB_EMPTY_BLOCKS|ASCB_FULL_BLOCKS|ASCB_INUSE_BLOCKS
RESULTS
	Total blocks counted
----------------------------------------------------------------------------
(asio.c)		ASFlush
----------------------------------------------------------------------------
NAME
	ASFlush
SYNOPSIS
	
	int ASFlush(as, keep)
	struct ActiveSample *as;
	int keep;
FUNCTION
	Flush all BigBlock full buffers except for the number passed
INPUTS
	keep	Number of BigBlock Buffers to keep.  If greater than
			the number of buffers full, then no buffers are flushed
RESULTS
	The number of buffers flushed
----------------------------------------------------------------------------
(asio.c)		ASHandlerQueryPlayData
----------------------------------------------------------------------------
NAME
	ASHandlerQueryPlayData
SYNOPSIS
	
	int ASHandlerQueryPlayData(as, len, actual_len, data)
	struct ActiveSample *as;
	unsigned long len;
	unsigned long *actual_len;
	short **data;
FUNCTION
	This function is called by audio handlers to access audio
	data.	 Typically, a handler waits for a Trigger message to
	start sound playback.  The handler then starts making calls
	to this function to get the data to play.	 These calls
	occur untill ASHandlerQueryPlayData() returns  STDERR_DATA_EOF.
	Data is available on the the EOF call.	 
INPUTS
	as		an Open ActiveSample
	len	The number of samples the handler wants
RESULTS
	actual_len	This is the number of samples available.	This
					will always match the 'len' except for two cases:
					1. The EOF call
					2. If your len is not evenly divisible into the 
						User's BigBlock size.  If you use 1K for len
						this will never happen.
	data			short *.	 Data buffer of length "actual_len"
RETURNS
	Standard error code: NO_ERROR, STDERR_DATA_NOT_AVAILABLE_YET,
	STDERR_DATA_EOF.	 If "STDERR_DATA_NOT_AVAILABLE_YET" is returned
	the caller should pause (e.g. WaitTOF()) then make the call
	again.
	The error code could be an error such as READ_ERROR.
----------------------------------------------------------------------------
(asio.c)		ASHandlerQueryRecordData
----------------------------------------------------------------------------
NAME
	ASHandlerQueryRecordData()
SYNOPSIS
	
	int ASHandlerQueryRecordData(as, len, actual_len, data)
	struct ActiveSample *as;
	unsigned long len;
	unsigned long *actual_len;
	short **data;

FUNCTION
	This function is called by audio handlers to access audio
	data buffers.	Typically, a handler waits for a Trigger message to
	start sound record.	The handler then starts making calls
	to this function to get the buffer where record data is stored
	in.  
INPUTS
	as		an Open ActiveSample
	len	The number of samples the handler wants
RESULTS
	actual_len	This is the size of the available buffer.	 This
					will always match the 'len' except for one case:
						If your len is not evenly divisible into the 
						User's BigBlock size.  If you use 1K for len
						this will never happen.
	data			short *.	 Data buffer of length "actual_len"
RETURNS
	Standard error code: NO_ERROR, STDERR_DATA_NOT_AVAILABLE_YET,
	STDERR_DATA_EOF.	 If "STDERR_DATA_NOT_AVAILABLE_YET" is returned
	the caller should pause (e.g. WaitTOF()) then make the call
	again.
----------------------------------------------------------------------------
(asio.c)		ASOpen
----------------------------------------------------------------------------
NAME
	ASOpen
SYNOPSIS
	
	struct ActiveSample *ASOpen(region, flags)
	struct Region *region;
	unsigned long flags;
FUNCTION
	Prepares a sample for record or playback.	Returns
	an ActiveSample pointer which you use like a file pointer.
	See studio16.h for the region structure.	You will need to
	fill in the following paramaters:
		myregion.samp_name	Sample name to play/record from/to
		myregion.start			First sample to play/record on top of
		myregion.end			Last sample
		myregion.parms			Sampling rate, etc. to use.
		myregion.user_data	Use for what ever you want

	You must also pass a flags variable. Either AS_PLAY or AS_RECORD
	must be selected.	 You can also select:

	AS_AUTO_DATA	if you want diskio to automatically read/write data
						to disk.	 This flag is usually set.
	AS_AUTO_CLOSE	if you want ASClose() to be called by diskio after
						playback/record completes.	 During play, ASClose()
						will be called automatically after the sound
						finishes playing naturally or by ASStop().
						ASClose() is called during record after ASStop().
	AS_AUTO_FREECHAN	This will cause "FreeChan(as->key)" to be made
							automaticlly upon play/record completion,
							or a call to ASClose().

	ASOpen allocates the ActiveSample struct and the four
	buffers used during record/playback.  If the sample is
	for playback, ASRead() is called four times to prefill the
	buffers.
INPUTS
	struct Region *
	flags (AS_RECORD, AS_PLAY, etc.)
RESULTS
	NULL if an error or ActiveSample *
----------------------------------------------------------------------------
(asio.c)		ASPos
----------------------------------------------------------------------------
NAME
	ASPos
SYNOPSIS
	
	unsigned long ASPos(as)
	struct ActiveSample *as;
FUNCTION
	For playback, determine the approximate sample number, relative
	to the beginning of the sample that is playing.  For the AD1012
	this is can by off by as much as 6K.
	For record, ASPos returns the approximate number of bytes recorded
	to disk so far.
INPUTS
	as		ActiveSample pointer
RESULTS
	Position in samples
----------------------------------------------------------------------------
(asio.c)		ASQueueReads
----------------------------------------------------------------------------
NAME
	ASQueueReads
SYNOPSIS
	
	void ASQueueReads(as, num)
	struct ActiveSample *as;
	int num;
FUNCTION
	Tell Diskio to call ASRead() a given number of times
INPUTS
	as		ActiveSample pointer
RESULTS
	NONE
----------------------------------------------------------------------------
(asio.c)		ASRead
----------------------------------------------------------------------------
NAME
	ASRead
SYNOPSIS
	
	int ASRead(as)
	struct ActiveSample *as;
FUNCTION
	Reads one "big_block" from disk.	 This is normally called
	by system routines, such as diskio.
INPUTS
	Active Sample struct
RESULTS
	standard error code (NO_ERROR, etc.)
----------------------------------------------------------------------------
(asio.c)		ASSeek
----------------------------------------------------------------------------
NAME
	ASSeek
SYNOPSIS
	
	int ASSeek(as, numsamps, mode)
	struct ActiveSample *as;
	long numsamps;
	long mode;
FUNCTION
	Seeks within a sample "ASOpen()"'ed.  Currently only works
	for AS_PLAY and not AS_RECORD samps.
	Can be called before or after ASTrigger(). However, the
	ASSeek does not take effect until the next Block of data
	is read (i.e, the next ASRead()).  Furthermore, the next
	ASRead() is generally three BigBlock's worth of data behind
	the data currently playing.  For Seeks to occur immediately,
	use:
		numflushed=ASFlush(as,0);
		ASSeek(as, x, AS_XX);
		ASQueueReads(as, numflushed);

	However, this example is reliable if the sample is not yet
	triggered.
INPUTS
	as			ActiveSample *
	numsamps Seek this many samples
	mode		numsamps is relative (ASS_OFFSET_CURRENT) or
				absolute (ASS_OFFET_BEGINNING)
RESULTS
	NONE
----------------------------------------------------------------------------
(asio.c)		ASStop
----------------------------------------------------------------------------
NAME
	ASStop
SYNOPSIS
	
	void ASStop(as)
	struct ActiveSample *as;
FUNCTION
	Broadcasts se_cmd_stop_recording or se_cmd_stop_playback
	as required and waits for the sample to stop play/record.
INPUTS
	ActiveSample struct
RESULTS
	NONE
----------------------------------------------------------------------------
(asio.c)		ASTrigger
----------------------------------------------------------------------------
NAME
	ASTrigger
SYNOPSIS
	
	void ASTrigger(as)
	struct ActiveSample *as;
FUNCTION
	broadcasts se_cmd_trigger_record or se_cmd_trigger_playback
	as required
INPUTS
	ActiveSample struct
RESULTS
	NONE
----------------------------------------------------------------------------
(asio.c)		ASTriggerList
----------------------------------------------------------------------------
NAME
	ASTriggerList
SYNOPSIS
	
	void ASTriggerList(as,flags)
	struct ActiveSample *as[];
FUNCTION
	broadcasts se_cmd_trigger_record or se_cmd_trigger_playback
	as required
INPUTS
	NULL terminated array of ActiveSample struct pointers
	flags
RESULTS
	NONE
----------------------------------------------------------------------------
(asio.c)		ASWaitStop
----------------------------------------------------------------------------
NAME
	ASWaitStop()
SYNOPSIS
	
	void ASWaitStop(as)
	struct ActiveSample *as;
FUNCTION
	Waits for the triggered sample to stop playing/recording
INPUTS
	ActiveSample struct
RESULTS
	NONE
----------------------------------------------------------------------------
(asio.c)		ASWrite
----------------------------------------------------------------------------
NAME
	ASWrite
SYNOPSIS
	
	int ASWrite(as)
	struct ActiveSample *as;
FUNCTION
	Writes one big block of data to disk
INPUTS
	ActiveSample struct
RESULTS
	standard error code like NO_ERROR
----------------------------------------------------------------------------
(studio.c)		BroadcastAndLock
----------------------------------------------------------------------------
NAME
	BroadcastAndLock -
SYNOPSIS
	
	void BroadcastAndLock(type, arg1, arg2, arg3, arg4, arg5, flags)
	
	short type;
	unsigned long arg1;
	unsigned long arg2;
	unsigned long arg3;
	unsigned long arg4;
	unsigned long arg5;
	unsigned long flags;

FUNCTION
	Sends an event message to all all modules who are listening for
	the type being broadcast.

	A "MemLock" is created with a count of the number of events sent.
	The Studio16 task who process replyed messages decrements this
	count.  Once the count reaches zero, it notifies FreeAfterUnlocked()
	that it is OK to free any memory beginning with arg1.

	This allows you to alloc memory with AllocMem(), broadcast a
	message using a pointer to the memory as an argument, then
	free the memory via UnlockedFreeMem() without worrying about
	freeing the memory before taskes receiving a pointer to it
	have processed it.  Of course, you must make sure that all
	modules using this type of argument process that argument completely
	before replying to the message.

INPUTS
	type - numeric value of message type. Returned from GetEventID()
	arg1 - arg5 message dependant arguments
	arg1 - pointer to memory being locked
	flags - message dependant flags

RESULTS
	NONE
----------------------------------------------------------------------------
(studio.c)		BroadcastEventParms
----------------------------------------------------------------------------
NAME
	BroadcastEventParms -
SYNOPSIS
	
	void BroadcastEventParms(type, arg1, arg2, arg3, arg4, arg5, flags)
	
	short type;
	unsigned long arg1;
	unsigned long arg2;
	unsigned long arg3;
	unsigned long arg4;
	unsigned long arg5;
	unsigned long flags;

FUNCTION
	Sends an event message to all all modules who are listening for
	the type being broadcast.	See GetEventID() for an example.
INPUTS
	type - numeric value of message type. Returned from GetEventID()
	arg1 - arg5 message dependant arguments
	flags - message dependant flags
RESULTS
	NONE
----------------------------------------------------------------------------
(studio.c)		BroadcastEventParmsLessOne
----------------------------------------------------------------------------
NAME
	BroadcastEventParmsLessOne -
SYNOPSIS
	
	void BroadcastEventParmsLessOne(type, thismod, arg1, arg2, arg3, arg4, arg5, flags)
	short type;
	struct Module *thismod;
	unsigned long arg1;
	unsigned long arg2;
	unsigned long arg3;
	unsigned long arg4;
	unsigned long arg5;
	unsigned long flags;

FUNCTION
	Sends an event message to all modules who are listening for
	the type being broadcast except the calling module.
	
INPUTS
	type - numeric value of message type. Returned from GetEventID()
	thismod - Don't send the message to this module
	arg1 - arg5 message dependant arguments
	flags - message dependant flags
RESULTS
	NONE
----------------------------------------------------------------------------
(studio.c)		BroadcastEventParmsLessOnePort
----------------------------------------------------------------------------
NAME
	BroadcastEventParmsLessOnePort -
SYNOPSIS
	
	void BroadcastEventParmsLessOnePort(type, port, arg1, arg2, arg3, arg4, arg5, flags)
	
	short type;
	struct MsgPort *port;
	unsigned long arg1;
	unsigned long arg2;
	unsigned long arg3;
	unsigned long arg4;
	unsigned long arg5;
	unsigned long flags;

FUNCTION
	Sends an event message to all modules/ports who are listening for
	the type being broadcast except the port passed.
	
INPUTS
	type - numeric value of message type. Returned from GetEventID()
	thismod - Don't send the message to this module
	arg1 - arg5 message dependant arguments
	flags - message dependant flags
RESULTS
	NONE
----------------------------------------------------------------------------
(studio.c)		ClearNotifyList
----------------------------------------------------------------------------
NAME
	ClearNotifyList-
SYNOPSIS
	
	void ClearNotifyList(type)
	short type;
FUNCTION
	Tells studio16 to stop sending events of a specified type
	to everyone currently listening for them.	 Be carefull using this
	since it may cause modules expecting certain events to
	suddenly quit receiving them without notice.
INPUTS
	type ID of event to quit broadcasting
RESULTS
	NONE
----------------------------------------------------------------------------
(standardenvironment.c)		CloseAllModules
----------------------------------------------------------------------------
NAME
	CloseAllModules
SYNOPSIS
	
	void CloseAllModules(callerismodule)
	int callerismodule;
FUNCTION
	Send's "SE_CMD_KILL_MOUDLE" messages to all resident
	studio16 modules, in the appropriate order for a clean
	shut down.

	After all modules are close, the following code is 
	executed:
		if (StudioBase->quit_task)
			Signal(StudioBase->quit_task,1<<StudioBase->quit_sigbit);
INPUTS
	callerismoudle		set to TRUE if the caller is a currently
							resident module (like "Quit"), otherwise
							FALSE (like shell cmd "StudioClose")
RESULTS
	None
----------------------------------------------------------------------------
(studio.c)		DeleteAudioHandler
----------------------------------------------------------------------------
NAME
	DeleteAudioHandler -
SYNOPSIS
	
	void DeleteAudioHandler(ah)
	struct AudioHandler *ah;
FUNCTION
	Removes an AudioHandler from the system's list.   Call
	DeleteHandler() as part of a device driver's close down sequence,
	along with such functions as DeleteModule().
INPUTS
	pointer to the AudioHandler to remove.
RESULTS
	NONE
----------------------------------------------------------------------------
(ff.c)		DeleteFileFilter
----------------------------------------------------------------------------
NAME
	DeleteFileFilter -
SYNOPSIS
	
	void DeleteFileFilter(ff)
	struct FileFilter *ff;
FUNCTION
	Remove a previously added file filter from StudioBase.
	File filters are use to translate Sample files upon load
	to/from studio 16's internal format.
INPUTS
	pointer to a FileFilter that was returned from AddFileFilter()
RESULTS
	NONE
----------------------------------------------------------------------------
(module.c)		DeleteModState
----------------------------------------------------------------------------
NAME
	DeleteModState -
SYNOPSIS
	
	void DeleteModState(s)
	
	struct StandardModState *s;

FUNCTION
	Unlinks and deallocates a ModState structure.  Will also
	broadcast the se_info_state_deleted message.
INPUTS
	s	Pointer to the ModState to delete
RESULTS
	NONE
----------------------------------------------------------------------------
(module.c)		DeleteModule
----------------------------------------------------------------------------
NAME
	DeleteModule -
SYNOPSIS
	
	void DeleteModule(m)
	struct Module *m;			/** Module to delete **/
FUNCTION
	Deallocates a module's memory and removes it from the module
	list.	 The passed module must be linked to StudioBase->Modules.
	The module's notifyme port is also closed and all references
	that will cause events to be sent to the specified module
	are removed.
INPUTS
	pointer to struct Module
RESULTS
	NONE
----------------------------------------------------------------------------
(regions.c)		DeleteRegionBySfp
----------------------------------------------------------------------------
NAME
	DeleteRegionBySfp
SYNOPSIS
	
	int DeleteRegionBySfp(sfp, regionname)
	struct SampleFilePointer *sfp;
	char *regionname;

FUNCTION
	Given a pointer to an Open Sample, this function will search
	the sample for a region who matches the passed name and remove
	it.
INPUTS
	sfp			Indicates which sample to scan
	regionname	just the region name.  No sample name prefixs
RESULTS
	standard error code
----------------------------------------------------------------------------
(samples.c)		DeleteSample
----------------------------------------------------------------------------
NAME
	DeleteSample -
SYNOPSIS
	
	int DeleteSample(name)
	char *name;

FUNCTION
	Given a complete path to a sample, this will attempt to
	delete's the sample's file + .graph file,
	and broadcasts the "SE_INFO_SAMPLE_DELETED"	event.
INPUTS
	name of sample to delete (not a complete path)
RESULTS
	standard error code
----------------------------------------------------------------------------
(smpte.c)		DeleteSmpteSink
----------------------------------------------------------------------------
NAME
	DeleteSmpteSink
SYNOPSIS
	void DeleteSmpteSink(ss)
	struct SmpteSink *ss;
FUNCTION
	Removes a Smpte Sink from the chain.
INPUTS
	ss - pointer to the SmpteSink that is to be removed.
	
RESULTS
	NONE
----------------------------------------------------------------------------
(smpte.c)		DeleteSmpteSource
----------------------------------------------------------------------------
NAME
	DeleteSmpteSource
SYNOPSIS
	void DeleteSmpteSource(ss)
	struct SmpteSource *ss;
FUNCTION
	Removes a SmpteSource from the chain.  If this source is the active
	one it sets StudioBase->CurrentSmpteSource=NULL, if this is the last
	smpte source to be deleted, it will remove the timeout task.
INPUTS
	ss - a pointer to the smpte source to be removed.
RESULTS
	
----------------------------------------------------------------------------
(studio.c)		FindAudioHandler
----------------------------------------------------------------------------
NAME
	FindAudioHandler -
SYNOPSIS
	
	struct AudioHandler *FindAudioHandler(last_han, flags, num_bits, name, class_id)
	struct AudioHandler *last_han;
	unsigned long flags;
	short num_bits;
	short class_id;
	char *name;
FUNCTION
	Searchs for an Amiga audio handler that matches the
	passed parameters
INPUTS
	last_han		Start searching with this handler (do not include
					this handler in the search.) NULL means start
					at beginning of list.
	flags			Search for a handler that matches these flags.
					eg. CK_CHAN_PLAY.	 If you don't care about flags,
					set it to -1;
	num_bits		Search for a handler that is the specified number
					of bits.	 Set to zero if you don't care how
					many bits.
	name			Search for a handler with this name.  NULL if
					you don't care about the name.
	class_id		Search for this particular instance of a handler
					with name 'name'.	 For example, if you had
					two AD1012 cards, there would be two handlers.
					Their class_id's would be 0 & 1.  Use -1 for
					a wildcard.

EXAMPLE
	To search for all 12 bit handlers in the system you would use:

	han = NULL;
	do {
		han = FindAudioHandler(han,-1,12,NULL,-1);
		if (han)
			printf("found han %x %s\n",han,han->name);
		} while (han);

RESULTS
	NULL or the audio handler that matches the request
----------------------------------------------------------------------------
(module.c)		FindModState
----------------------------------------------------------------------------
NAME
	FindModState -
SYNOPSIS
	
	
	struct StandardModState *FindModState(name)
	char *name;

FUNCTION
	Searchs for a prexisting mod state. Search order is:
	1) any module with same name & MS_NEED_MODULE flag set
	2) any module with same name
INPUTS
	module name (should match file name of module)
RESULTS
	struct StandardModState *
----------------------------------------------------------------------------
(module.c)		FindModule
----------------------------------------------------------------------------
NAME
	FindModule -
SYNOPSIS
	
	struct Module *FindModule(name)
	char *name;		/* module name to search for **/
FUNCTION
	Searchs the module list for a module with the passed name.
	Treats upper and lower case the same.
INPUTS
	pointer to name to search for
RESULTS
	pointer to struct Module or NULL
----------------------------------------------------------------------------
(regions.c)		FindRegion
----------------------------------------------------------------------------
NAME
	FindRegion
SYNOPSIS
	
	
	int FindRegion(name, region)
	char *name;
	struct Region *region;

FUNCTION
	Given a region name, this will fill in the passed region structure.
	The region name can have the from of "SampleName" or
	"SampleName.Region".  For example "Fred" would return a region
	encompassing the entire sample "Fred", and "Fred.Yow" would
	return the "Yow" region, which should be defined in "Fred"

	This function requires complete paths.  EG "DH0:proj1/samp.reg"
INPUTS
	name			SampleName.RegionName (complete path!)
	regio			This is filled in if name is found.
RESULTS
	standard error code
----------------------------------------------------------------------------
(regions.c)		FindRegionBySfp
----------------------------------------------------------------------------
NAME
	FindRegionBySfp
SYNOPSIS
	
	int FindRegionBySfp(sfp, regionname, region)
	struct SampleFilePointer *sfp;
	char *regionname;
	struct Region *region;

FUNCTION
	Given a pointer to an Open Sample, this function will search
	the sample for a region who matches the passed name.
INPUTS
	sfp			Indicates which sample to scan
	regionname	just the region name.  No sample name prefixs
	regin			This is filled if regionname is found.
RESULTS
	standard error code
----------------------------------------------------------------------------
(samples.c)		FindSample
----------------------------------------------------------------------------
NAME
	FindSample -
SYNOPSIS
	
	char *FindSample(name)
	char *name;
FUNCTION
	Searchs for the specified sample in each of the default.samp_paths.
	Treats upper and lower case the same.
	Must be called from a DOS Process, not just an Exec Task.
	Regions are ignored.  For example, "fred.region" would
	find the sample "fred"
INPUTS
	pointer to name to search for
RESULTS
	pointer to the path where sample was found, or NULL.
----------------------------------------------------------------------------
(studio.c)		FreeChan
----------------------------------------------------------------------------
NAME
	FreeChan -
SYNOPSIS
	
	void FreeChan(key)
	struct ChanKey *key;

FUNCTION
	Frees a previously allocated channel.
INPUTS
	*key returned by AllocChan()
RESULTS
	NONE
----------------------------------------------------------------------------
(smpte.c)		Frm
----------------------------------------------------------------------------
NAME
	Frm2TC
SYNOPSIS
	int Frm2TC(frm,mode)
	int frm,mode;
FUNCTION
	This function converts a frame number into a timecode.
INPUTS
	frm - int of a number of frames
	mode - smpte_mode
RESULTS
	Int/TimeCode
----------------------------------------------------------------------------
(studio.c)		GetEventID
----------------------------------------------------------------------------
NAME
	GetEventID -
SYNOPSIS
	
	GetEventID(name)
	char *name;

FUNCTION
	Takes a pointer to a string and returns its ID number.  In 
	Studio 16, "Events" are used to communicate between modules.
	In order to broadcast an event, you must get its ID. ID's are
	assigned dynamicaly at runtime for maximum flexability.	For
	example, to play a sample you could use the sequence:
	
	int playid;
	playid = GetEventID("SE_CMD_PLAY_SAMPLE");
	if (playid!=-1) {
		BroadcastEventParms(playid, samp, 0, samp->length, 0,0,0);
		}

INPUTS
	name	pointer to the name of a studio event
RESULTS
	Event id (int) or -1 if out of memory
----------------------------------------------------------------------------
(ff.c)		GetFileFilter
----------------------------------------------------------------------------
NAME
	GetFileFilter
SYNOPSIS
	
	struct FileFilter *GetFileFilter(name)
	char *name;
FUNCTION
	Given the name of a file filter, determine its pointer.
INPUTS
	name	name of the file filter
RESULTS
	NONE
----------------------------------------------------------------------------
(ff.c)		GetFileType
----------------------------------------------------------------------------
NAME
	GetFileType
SYNOPSIS
	
	struct FileFilter *GetFileType(buf,fmode,ptr)
	char *buf;
	long fmode;
	long *ptr;
FUNCTION
	Determine FileFilter that can decode a given sample with
	the indicated access mode.
INPUTS
	buf complete path ponting to file
	mode MODE_OLDFILE, MODE_NEWFILE, MODE_READWRITE
	ptr   An optional pointer to a long.  If this is non null,
			GetFileType(), MAY fill it in with a non null
			handle from FFOpen().  This is used by internal
			Studio 16 routines to speed up cases that must
			immediately recall FFOpen().
RESULTS
	NULL if no qualified FileFilter available, or FileFilter pointer.
----------------------------------------------------------------------------
(module.c)		GetModuleNum
----------------------------------------------------------------------------
NAME
	GetModuleNum -
SYNOPSIS
	
	int GetModuleNum(m)
	struct Module *m;
FUNCTION
	Given a pointer to a module, returns the index of that module
	in the linked list of modules.
INPUTS
	module pointer
RESULTS
	Module index
----------------------------------------------------------------------------
(studio.c)		IgnoreCount
----------------------------------------------------------------------------
NAME
	IgnoreCount-
SYNOPSIS
	
	void IgnoreCount(type, module)
	short type;
	struct Module *module;
FUNCTION
	Tells studio16 to quit sending SE_INFO_EVENT_COUNT messages
	to a specifed module.
INPUTS
	type - type of messages to quit counting
	module - module to quit receiving messages
RESULTS
	NONE
----------------------------------------------------------------------------
(studio.c)		IgnoreEvent
----------------------------------------------------------------------------
NAME
	IgnoreEvent -
SYNOPSIS
	
	void IgnoreEvent(type, module)
	short type;
	struct Module *module;
FUNCTION
	Tells studio16 to quit sending events of the specified type
	to the specified module.  For example, if you have been listening
	to smpte messages, but don't want to any more you could say

		IgnoreEvent(se_info_smpte, thismodptr);

	where se_info_smpte was a short filled in with a call to
	GetEventID(); 
INPUTS
	type ID of message type to quit receiving
	module pointer to module that doesn't want messages any more
RESULTS
	NONE
----------------------------------------------------------------------------
(studio.c)		IgnoreEventPort
----------------------------------------------------------------------------
NAME
	IgnoreEventPort -
SYNOPSIS
	
	void IgnoreEventPort(type, port)
	short type;
	struct MsgPort *port;
FUNCTION
	Tells studio16 to quit sending events of the specified type
	to the specified port;
INPUTS
	type 	ID of message type to quit receiving
	port	MsgPort to quit receiving events.
RESULTS
	NONE
----------------------------------------------------------------------------
(standardenvironment.c)		InitStudio
----------------------------------------------------------------------------
NAME
	InitStudio16UserEnv
SYNOPSIS
	
	int InitStudio16UserEnv(flags, myscreen, mybackwin)
	unsigned long flags;
	struct Screen *myscreen;
	struct Window *mybackwin;
FUNCTION
	Only the first call to this function does anything.  All
	subsequent calles are ignored (unless you set the
	ISUE_FORCE flag.  However, this flag should be used
	carefully, and never from within a Studio 16 module.)
	The first call to this function after opening Studio.library
	allows you to setup the users enviroment to various defaults.

	If the standard studio16 screen isn't open, this will
	open it, provided ISUE_OPEN_DEF_SCREEN is set.	All modules
	that expect a screen pointer in StudioBase may call this
	before opening their windows.

	Set any of the following flags:
	
	ISUE_DO_ASSIGNS					** Assign Studio16: **
	ISUE_LOAD_STUDIO16INSTANCE		** LoadModState(0) **
	ISUE_LOAD_STUDIO16BASE			** LoadDefaults(0) ***
	ISUE_OPEN_DEF_SCREEN				** OpenScreen() 3 BitPlanes **
	ISUE_USE_MY_SCREEN				** use passed params **
	ISUE_LOAD_DRIVERS					** load drivers & utilites **

	ISUE_FORCE							** Allow a call after first **

INPUTS
	flags			See above
	myscreen		Screen pointer used if ISUE_USE_MY_SCREEN is passed
	mybackwin	Backdrop window used if ISUE_USE_MY_SCREEN is passed
RESULTS
	standard error code
----------------------------------------------------------------------------
(studio.c)		LoadDefaults
----------------------------------------------------------------------------
NAME
	LoadDefaults -
SYNOPSIS
	
	void LoadDefaults(file)
	char *file;		/** complete path/file pointing to defaults or NULL **/
FUNCTION
	trys to load defaults from the specified file.	Defaults
	are things like screen size, colors.  Buffer sizes, etc.
	(all things in MasterPrefs.)
INPUTS	
	ARGS:
		1	pointer to string containing complete path of file
			containing defaults to try and load.  NULL means use
			default ("s:studio16base.config")
RETURNS
	NONE
----------------------------------------------------------------------------
(studio.c)		LoadModState
----------------------------------------------------------------------------
NAME
	LoadModState -
SYNOPSIS
	
	int LoadModState(file)
	char *file;
FUNCTION
	Load's a file containg ModStates and appends them to 
	StudioBase's list.  This is the opposite of SaveModState();
	Existing modstates are not altered.
INPUTS	
	ARGS:
		1	pointer to string containing complete path of file
			To load from.	Zero means use default name
			 (s:Studio16Instance.config)
RETURNS
	standard error code.
----------------------------------------------------------------------------
(studio.c)		LoadModule
----------------------------------------------------------------------------
NAME
	LoadModule -
SYNOPSIS
	
	struct Module *LoadModule(name)
	char *name;

FUNCTION
	Given a module name, this function will load its code
	and launch it as a new process.  If you specify a directory
	in your module name, that directory will be appened to
	Studio16: then searched.  EG:
					LoadModule("Apps/Meters");
	Alternatly, if no subdirectory is given, Studio16:Apps will
	be searched first, followed by Utilites, Drivers, and
	ProjectMenu.
INPUTS
	char * name		module file name 
RESULTS
	struct *Module
----------------------------------------------------------------------------
(studio.c)		MoveRequester
----------------------------------------------------------------------------
NAME
	MoveRequester
SYNOPSIS
	void MoveRequester(pr)
	struct Process *pr;
FUNCTION
	Calling this will cause subsequent DOS error requesters
	to appear on the studio16 screen.
INPUTS
	pointer to a process structure
RESULTS
	NONE
----------------------------------------------------------------------------
(studio.c)		NotifyMeOnCount
----------------------------------------------------------------------------
NAME
	NotifyMeOnCount -
SYNOPSIS
	
	void NotifyMeOnCount(type, module)
	short type;
	struct Module *module;
FUNCTION
	Tells studio16 to inform a module every time the number of
	modules listening for a particular ID changes.	The module
	wanting notices will receive messages of type "SE_INFO_EVENT_COUNT"
	(arg1 is the event type and arg 2 is the number of modules
	listening for event)
INPUTS
	type - message type to keep track of listners
	module - module to recieve SE_INFO_EVENT_COUNT messages
RESULTS
	NONE
----------------------------------------------------------------------------
(studio.c)		NotifyMeOnEvent
----------------------------------------------------------------------------
NAME
	NotifyMeOnEvent -
SYNOPSIS
	
	void NotifyMeOnEvent(type, module)
	short type;
	struct Module *module;
FUNCTION
	Tells studio16 that you want to recieve events of a certian
	type when they are broadcast.
INPUTS
	type ID of event you wish to receive
	module the module that wants to receive events
RESULTS
	NONE
----------------------------------------------------------------------------
(studio.c)		NotifyMeOnEventPort
----------------------------------------------------------------------------
NAME
	NotifyMeOnEventPort -
SYNOPSIS
	
	void NotifyMeOnEventPort(type, port)
	short type;
	struct MsgPort *port;
FUNCTION
	Receive studio 16 "struct StudioEvent" on any Exec MsgPort.
	You must ReplyMsg() the event after you receive it.
INPUTS
	type	ID of event type you wish to receive.
	port	MsgPort to receive event
RESULTS
	NONE
----------------------------------------------------------------------------
(smpte.c)		QuerySmpteTime
----------------------------------------------------------------------------
NAME
	QuerySmpteTime
SYNOPSIS
	
	int QuerySmpteTime()
FUNCTION
	Gets the current smpte time code.
INPUTS
	none
RESULTS
	current time code value (int).
----------------------------------------------------------------------------
(samples.c)		RenameSample
----------------------------------------------------------------------------
NAME
	RenameSample -
SYNOPSIS
	
	int RenameSample(src_path,src_name,dest_path,dest_name)
	char *src_path, *dest_path;
	char *src_name, *dest_name;
FUNCTION
	Rename's a sample.  sample_deleted & sample_created messages
	are sent out.  A .graph file is also renamed, if one
	exists.
INPUTS
	src_path		path of file to rename
	src_name		name of file to rename.  Can be null if 
					src_path is complete.
	dest_path	path of file to rename to.
	dest_name	name of file to rename to.  Can be null if dest_path
					is complete.
RESULTS
	stanard error code
----------------------------------------------------------------------------
(studio.c)		RestoreWindowParms
----------------------------------------------------------------------------
NAME
	RestoreWindowParms-
SYNOPSIS
	
	
	void RestoreWindowParms(m,nw)
	struct Module *m;
	struct NewWindow *nw;

FUNCTION
	OBSOLETE!!!
INPUTS
RESULTS
	NONE
----------------------------------------------------------------------------
(sampleio.c)		SampleClose
----------------------------------------------------------------------------
NAME
	SampleClose
SYNOPSIS
	
	int SampleClose(sp)
	struct SampleFilePointer *sp;
FUNCTION
	Release a SampleFilePointer obtained with SampleOpen().
	This also calls SampleWriteTag() if the file being closed
	is SP_MODE_READWRITE or SP_MODE_NEWFILE
INPUTS
	sp	SampleFilePointer returned by SampleOpen()
RESULTS
	Returns Zero if successful
----------------------------------------------------------------------------
(sampleio.c)		SampleCopy
----------------------------------------------------------------------------
NAME
	SampleCopy
SYNOPSIS
	
	int SampleCopy(tosp, fromsp, length)
	struct SampleFilePointer *tosp;
	struct SampleFilePointer *fromsp;
	int length;
FUNCTION
	Copy data from one SampleFilePointer to another using
	multiple SampleRead()/SampleWrite()s.
	StudioBase->defaults.copy_buf_size is used to determine
	how big a temporary buffer to allocate.
INPUTS
	tosp		SampleFilePointer returned by SampleOpen()
	fromsp	SampleFilePointer returned by SampleOpen()
	length	Number of samples to copy
RESULTS
	Returns standard error code (NO_ERROR if ok)
----------------------------------------------------------------------------
(sampleio.c)		SampleCreate
----------------------------------------------------------------------------
NAME
	SampleCreate -
SYNOPSIS
	
	struct SampleFilePointer *SampleCreate(name)
	char *name;
FUNCTION
	Calls SampleOpen(name, SP_MODE_NEWFILE, NULL)
INPUTS
	name	A pointer to the name of the sample to create.
RESULTS
	Sample pointer or NULL if can't create sample.
----------------------------------------------------------------------------
(sampleio.c)		SampleGetOne
----------------------------------------------------------------------------
NAME
	SampleGetOne -
SYNOPSIS
	
	short SampleGetOne(sp, i)
	struct SampleFilePointer *sp;
	long i;
FUNCTION
	Given a SampleFilePointer (which should be obtained by calling
	SampleOpen(), this funciton will return one sample.
INPUTS
	sp sample pointer to opened sample
	i index (0 to sample_len - 1) of sample to return
RESULTS
	a short sample value
----------------------------------------------------------------------------
(sampleio.c)		SampleOpen
----------------------------------------------------------------------------
NAME
	SampleOpen -
SYNOPSIS
	
	struct SampleFilePointer *SampleOpen(name, flags, dff)
	char *name;
	long flags;
	struct FileFilter *dff;
FUNCTION
	returns sample pointer which you can use in calls to
	SampleRead(), SampleWrite(), etc.  SampleOpen() requires
INPUTS
	name	A complete Ascii path pointer to a file.  For
			Example, "DH0:Project1/Bang"
	flags	way to access sample (SP_MODE_OLDFILE,
			SP_MODE_NEWFILE, SP_MODE_READWRITE)
	ff		FileFilter to use when accessing file, or NULL for
			default.file_filter_name on writes and autodetect on reads.
RESULTS
	SampleFilePointer or NULL if can't open sample
----------------------------------------------------------------------------
(sampleio.c)		SampleRead
----------------------------------------------------------------------------
NAME
	SampleRead -
SYNOPSIS
	
	int SampleRead(sp, buffer, length)
	struct SampleFilePointer *sp;
	short *buffer;
	long length;
FUNCTION
	This is similars to a dos Read() function, except it deals
	with sample files.  SampleRead understands file formats and
	DataClips inside a sample and deals with them.   You can
	use SampleSeek() to find the beginning of a sample's data.
INPUTS
	sp sample pointer to opened sample
	buffer pointer to memory to fill with data
	length number of samples to read (not bytes!) Make sure
			your buffer points to length*2 bytes!
RESULTS
	the number of samples actually read
----------------------------------------------------------------------------
(sampleio.c)		SampleReadTag
----------------------------------------------------------------------------
NAME
	SampleReadTag -
SYNOPSIS
	
	int SampleReadTag(sp)
	struct SampleFilePointer *sp;
FUNCTION
	Causes the FileFilter to fill in the SampleFileTag structure
	by reading the appropriate fields (as known by the file filter)
	from the sample's disk file.
	This is normally only called by system functions.
INPUTS
	sp		result from SampleOpen()
RESULTS
	standard error code
----------------------------------------------------------------------------
(sampleio.c)		SampleSeek
----------------------------------------------------------------------------
NAME
	SampleSeek -
SYNOPSIS
	
	int SampleSeek(sp, rpos, mode)
	struct SampleFilePointer *sp;
	long rpos;
	int mode;
FUNCTION
	This is similar to a dos Seek() function, except it deals
	with sample files.  Seeks to the specified position
	within a sample. Understands DataClips inside a sample 
	and deals with them. Thus, if the user has performed some
	non-destructive edits on the sample, the actual file position
	SampleSeek() seeks to probably won't match the position you
	pass since you are passing an edited position.

INPUTS
	sp sample pointer to opened sample
	rpos	Edit sample position to seek to
	mode  SS_OFFSET_END, SS_OFFSET_CURRENT, SS_OFFSET_BEGINNING
RESULTS
	Sample position upon call to SampleSeek()
----------------------------------------------------------------------------
(sampleio.c)		SampleWrite
----------------------------------------------------------------------------
NAME
	SampleWrite -
SYNOPSIS
	
	int SampleWrite(sp, buffer, length)
	struct SampleFilePointer *sp;
	short *buffer;
	long length;
FUNCTION
	This is similar to a dos Write() function, except it deals
	with sample files.  SampleWrite understands file formats and 
	DataClips inside a sample and deals with them. You can
	use SampleSeek() to find a position inside sample's data.
	Seeking to the middle of a sample, and calling SampleWrite()
	will cause the current data to be overwritten with the new
	data.  A sample will not be made shorter by writing to the
	middle of a sample.
INPUTS
	sp sample pointer to opened sample
	buffer pointer to memory to fill with data
	length number of samples to write (not bytes!) Make sure
			your buffer points to length*2 bytes!
RESULTS
	the number of samples actually written.  If this is shorter
	than length, an error (such as disk full) occured during the
	write.
----------------------------------------------------------------------------
(sampleio.c)		SampleWriteTag
----------------------------------------------------------------------------
NAME
	SampleWriteTag -
SYNOPSIS
	
	int SampleWriteTag(sp)
	struct SampleFilePointer *sp;
FUNCTION
	Causes a open sample's tag structure to be written out
	to disk via the FileFilter.  Not all file formats support
	all tag entries.  For example, RAW doesn't support any.

	If you change a sample's paramaters (such as playback speed)
	you should call SampleWriteTag() to update the disk file.

	SampleClose() will automaticlly call SampleWriteTag() if
	the file is MODE_NEWFILE or MODE_READWRITE.	
INPUTS
	sp		result from SampleOpen()
RESULTS
	std error code
----------------------------------------------------------------------------
(studio.c)		SaveDefaults
----------------------------------------------------------------------------
NAME
	SaveDefaults -
SYNOPSIS
	
	void SaveDefaults(file)
	char *file;		/** complete path/file pointing to defaults or NULL **/
FUNCTION
	saves the current StudioBase.defaults to disk
INPUTS	
	ARGS:
		1	pointer to string containing complete path of file
			containing defaults to try and write.	Zero means
			use default name.
RETURNS
	NONE
----------------------------------------------------------------------------
(studio.c)		SaveModState
----------------------------------------------------------------------------
NAME
	SaveModState -
SYNOPSIS
	
	
	int SaveModState(file)
	char *file;
FUNCTION
	saves the current list of ModStates.  The result is a snap
	shot of what windows are open, closed, etc.	It also saves
	any settings that a module has stored in a custom ModState.
INPUTS	
	ARGS:
		1	pointer to string containing complete path of file
			to write to.  Zero means use default name
			 (s:Studio16Instance.config)
RETURNS
	standard error code.
----------------------------------------------------------------------------
(studio.c)		SendMsg
----------------------------------------------------------------------------
NAME
	SendMsg -
SYNOPSIS
	
	void SendMsg(mod, type, arg1, arg2, arg3, arg4, arg5, flags)
	struct Module *mod;
	ULONG arg1, arg2, arg3, arg4, arg5,flags;
	short type;
FUNCTION
	Sends a message to one particular module.	 Use this if you
	know that only one specific module is waiting for a message.
	For example, Modlist sometimes uses this to send out
	SE_CMD_KILL_MODULE messages.	This reduces the message traffic by not
	sending SE_CMD_KILL_MODULE events to modules that don't need them.  
	However, this is also dangerous in that a module may be 
	interested in SE_CMD_KILL_MODULE events directed to other modules.
	Since SE_CMD_KILL_MODULE events are sometimes sent using SendMsg()
	and not BroadcastEventParms(), third party modules can't monitor
	SE_CMD_KILL_MODULE reliably. Use this function carefully.
INPUTS
	mod - module to receive message
	type - flags same as BroadcastEventParms()
RESULTS
	NONE
----------------------------------------------------------------------------
(studio.c)		SendMsgToPort
----------------------------------------------------------------------------
NAME
	SendMsgToPort -
SYNOPSIS
	
	void SendMsgToPort(port, type, arg1, arg2, arg3, arg4, arg5, flags)
	struct MsgPort *port;
	ULONG arg1, arg2, arg3, arg4, arg5,flags;
	short type;
FUNCTION
	Same as SendMsg(), except the message is sent to an
	Exec MsgPort instead of a Module struct.

	This call is different from the exec PutMsg() in that
	it allocates a StudioEvent structure to contain the message.
	In addition, the ReplyPort is correctly assigned to a 
	studio16 task who's job is to maintain the free list
	of StudioEvent structures.
INPUTS
	port - struct MsgPort * to receive message
	type - flags same as BroadcastEventParms()
RESULTS
	NONE
----------------------------------------------------------------------------
(studio.c)		SetOriginalDefaults
----------------------------------------------------------------------------
NAME
	SetOriginalDefaults -
SYNOPSIS
	
	void SetOriginalDefaults()
FUNCTION
	Sets up StudioBase.defaults to the original factory settings.
	Calling this will trash any user set defaults.
INPUTS	
	NONE
RETURNS
	NONE
----------------------------------------------------------------------------
(smpte.c)		SetSmpteSource
----------------------------------------------------------------------------
NAME
	SetSmpteSource
SYNOPSIS
	
	struct SmpteSource *SetSmpteSource(ss)
	struct SmpteSource *ss;
FUNCTION
	This function changes the current Smpte Souce to the new
	one.  you may find out the CurrentSmpteSource by reading the
	StudioBase->CurrentSmpteSource variable.
INPUTS
	ss - new Smpte Source
RESULTS
	returns the old Smpte Source
----------------------------------------------------------------------------
(standardenvironment.c)		StandardEnviroment
----------------------------------------------------------------------------
NAME
	StandardEnviroment -
SYNOPSIS
	
	int StandardEnviroment()
FUNCTION
		InitStudio16UserEnv(FLAGS, 0, 0);
		where FLAGS is:
		#define	FLAGS ISUE_DO_ASSIGNS|ISUE_LOAD_STUDIO16INSTANCE|
					ISUE_LOAD_STUDIO16BASE|
					ISUE_OPEN_DEF_SCREEN|ISUE_LOAD_DRIVERS
INPUTS
	NONE
RESULTS
	standard error code
----------------------------------------------------------------------------
(samples.c)		StrFileName
----------------------------------------------------------------------------
NAME
	StrFileName
SYNOPSIS
	
	char *StrFileName(char *path)
FUNCTION
	Given a string that is a complete path, this returns a
	pointer to the file name.  For example, if passed
	"DH0:dir1/fred", it would return a pointer to "fred".
INPUTS
	path
RESULTS
	Pointer to file name at end of path
----------------------------------------------------------------------------
(samples.c)		StrLastDir
----------------------------------------------------------------------------
NAME
	StrLastDir
SYNOPSIS
	
	char *StrLastDir(char *path)
FUNCTION
	Given a string that is a path, this returns a
	pointer to the last directory or device.  For example,
	"DH0:dir1", it would return a pointer to "dir1" and
	"DH0:" would return "DH0:".
INPUTS
	path
RESULTS
	Pointer to last dir, or if none exists, pointer to device.
----------------------------------------------------------------------------
(samples.c)		StrPathFileCat
----------------------------------------------------------------------------
NAME
	StrPathFileCat
SYNOPSIS
	char *StrPathFileCat(path,file)
	char *path,*file;
FUNCTION
	Concatinates a dos path and filename together resulting in a
	complete path in the path field
INPUTS
	char *path  char *file
RESULTS
	char * to complete path (same as *path)
----------------------------------------------------------------------------
(samples.c)		StrRegionName
----------------------------------------------------------------------------
NAME
	StrRegionName
SYNOPSIS
	
	char *StrRegionName(char *path)
FUNCTION
	Given a string that is a complete or partial path, this returns a
	pointer to the region name.  For example, if passed
	"DH0:dir1/fred>regiona", it would return a pointer to "regiona"
INPUTS
	path
RESULTS
	Pointer to region name at end of path or pointer to NULL if no region
----------------------------------------------------------------------------
(smpte.c)		TC
----------------------------------------------------------------------------
NAME
	TC2Frm
SYNOPSIS
	int TC2Frm(tc,mode)
	int tc,mode;
FUNCTION
	This function converts a timecode into a frame number.
INPUTS
	tc - in/TimeCode
	mode - smpte_mode
RESULTS
	# of frames
----------------------------------------------------------------------------
(smpte.c)		TCstr
----------------------------------------------------------------------------
NAME
	TCstr2int
SYNOPSIS
	int TCstr2int(TCstr)
	char *TCstr ;
FUNCTION
	This function converts a string into a TimeCode/int format.
INPUTS
	TCstr - pointer to a NULL terminated string
RESULTS
	Int/TimeCode
----------------------------------------------------------------------------
(unlockedfreemem.c)		UnlockedFreeMem
----------------------------------------------------------------------------
NAME
	UnlockedFreeMem
SYNOPSIS
	
	void UnlockedFreeMem(mem, size)
	APTR mem;
	unsigned long size;
FUNCTION
	This function is similar to the Exec FreeMem() call, except
	it will wait for the passed memory pointer to become
	"unlocked" if it notices that the memory pointer is locked.
	
	Memory becomes locked by using it as an argument in a call
	to BroadcastAndLock().  Once locked, the memory becomes
	unlocked when all broadasted messages have been replyed
	to.

	This allows you to allocate memory, broacast (via
	BroadcastAndLock()) a pointer to this memory, then
	free the memory via UnlockFreeMem() without worrying if
	the receiving tasks have processed their messages yet.

	All receiving tasks must not ReplyMsg() untill they
	have finished using the locked memory completely.
INPUTS
	mem	- pointer to memory to free
	size	- number of bytes to free
RESULTS
	NONE
----------------------------------------------------------------------------
(studio.c)		UpdateStandardModState
----------------------------------------------------------------------------
NAME
	UpdateStandardModState(m,w) -
SYNOPSIS
	
	void UpdateStandardModState(m,w)
	struct Module *m;
	struct Window *w;

FUNCTION
	OBSOLETE!!!
	Copies parameters into the m->state structure
INPUTS
RESULTS
	NONE
----------------------------------------------------------------------------
(studio.c)		WaitUntilListening
----------------------------------------------------------------------------
NAME
	WaitUntilListening -
SYNOPSIS
	
	void WaitUntilListening(type, mod)
	short type;
	struct Module *mod;

FUNCTION
	Wait for the indicated module to ask for notification on
	the passed event type before returning. (Specified mod
	must call NotifyMeOnEvent(type, mod)). Currently will
	TimeOut in 8 seconds.
INPUTS
	module, event type
RESULTS
	NONE
----------------------------------------------------------------------------
