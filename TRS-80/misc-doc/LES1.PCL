Anthony Wood12739 Grand Cross lnHouston, TX 77072(713) 495-4322           6502 Assembly Language Programing for the Beginner           Lesson #1 -- Computer orginization and                        number systems.     If you have no knowledge of assembly language programming, but wish to learn, this series is for you.  It will assume no prior experience in assembly language, and will start from the ground up.  Experience in BASIC programming will be helpful, but not required.     But, you might wonder, "If I can't even program in BASIC, how am I supposed to understand assembly language?" Well, i'm glad you asked, because thats an important question.  The answer lies in the fundamental difference between BASIC, a higher level language, and Assembly language, a very low level language.  If you understand BASIC, it is not too difficult to learn another high level language, such as FORTRAN, PL/1, or Pascal. Once you understand the logic behind programming one of these languages, you can switch the same concepts to another language.     However, assembly language has a basic difference from BASIC or FORTRAN--the methods you learned for programming in BASIC apply little, if any, to programming in assembly language.     Does this mean that assembly language programming is harder than BASIC?.  Most people do find assembly language more difficlult than BASIC; however, some people prefer to program in assembly, and many applications require it.     I have been talking about "assembly" language, yet you may have noticed that many people use the term "machine" language interchangably with assembly language.  There is a difference between the two, and I will cover it after I explain some hardware concepts.     Before you can program in assembly language, some knowledge of computer hardware (the electronics that make your computer) is needed.  The commodore 64, and all microcomputers, consist of three parts:  the microprocessor (also called a CPU--central processing unit), the memory, and input/output devices.     The microprocessor is the "brain" of the computer--inside the computer it is an actual chip.  The commodore 64 and Vic 20 both use a 6502 compatible microprocessor; therfore, this series covers 6502 assembly language--assembly language for one kind of microprocessor will not run on a different microprocessor. It is the 6502 microprocessor that runs your programs--it fetches instructions and data from memory and saves the results back in memory.  The commodore 64, in reality, uses a 6510 microprocessor--however, the 6510 is just a modified 6502 and runs the same assembly language as a 6502.     A microprocessor can only do very basic operations, such as load a number from memory, add or subtract, and save a number to memory.  Whenever the 6502 fetches a number from memory, it puts the number in a register.  A register is like a memory location, except it is part of the microprocessor. Each register can hold one byte, a number from 0 to 255.  In the 6502, there are six registers, the accumulator, X, Y, Stack pointer, Program counter, and the status byte, each of which is one byte in length, execpt for the program counter.  The accumulator is where the results of all math operations are stored.  The X and Y register are called index register; the puprpose of the X, Y and other registers will be explained later    Inside your computer, programs are stored in memory.  Each memory location of a computer is one byte in length, so each can store one number between 0 and 255. The commodore 64 has 65536 memroy locations, thus you can store 65536 numbers from 0 to 255 in memory. Everything you type into your computer is stored in memory as bytes, and all programs the computer runs are coded in memory as bytes.  Thus, the microprocessor only undersands numbers. Numbers mean things to the microprocessor, such as add two numbers, or subtract two numbers.     Each memory location inside the computer has an address, a number from 0 to 65535.  When the microprocessor access a memory location, it references it by that memory location's address.     Earlier I mentioned the "program counter."  The program counter is a register inside the 6502 microprocessor that contains the memory address of the current instruction. After each instruction is executed, the program counter is incremented to point to the next instrution.  This is how the micprocessor remembers which part of the program it is running.      Memory can be divided into two basic types: RAM (random access memory) and ROM (read only memory.) RAM is memory that can change. When you type in a BASIC program, it is stored in RAM.  ROM is memory that always contains the same thing--cartrige games are ROM.  RAM loses its information when the computer is turned off, and ROM does not.     The third section of a computer is the Input (keyboard, tape drive, etc.) and output (video display, tape when you save to it, etc.)  To the microprocessor, all input output devices appear to be memory locations.  For example, when an "A" is writen to the upper left of the screen, a 1 (the code for an "A") is actualy put into memory location 1024--the memory address that represents the upper left position on the screen.     As I mentioned before, there is a difference between assembly language and machine language.  Machine language is the actual numbers the microprocessor executes, but, since it is hard for humans to remember that a 40 means add two numbers, assemmbly language was created.  Assembly language allows you to represent machine language with symbols, such as ADC (add with carry) or STY (store register Y).     In order to run assembly language, you must have an assembler, a program tha converts assembly language to its machine language representation.  Many assemblers have been published in magazines, and they are also available from various software houses.  Since the only way to learn assembly is to try it for yourself, you will need to get an assembler to work the examples in this series.      Perhaps the question has occured to you, "If a microprocessor only understands machine language, why can I program in BASIC?" The answer is simple, BASIC is just a machine code program that understands what the BASIC commands mean.  This is why BASIC is slower than assembly language--all BASIC statments must be translated to machine language by the BASIC program.           Number System     In learning assembly language, you will need to learn some new number systems.  All numbers inside a computer are stored in "binary" notation.  Memory can only store two conditions "on" or "off".  In binary, these conditions are represented as "1" or "0".  Thus a binary number is a sequence of 1's and 0's. Each of these ones or zeros is called a bit.  A byte is made up of eight bits.  For example, the largest number that can be stored in a byte, 255, would be 11111111 in binary.     The number sytem you are used to using, decimal, is base ten.  Binary, however, is base two, and the only digits are 0 or 1 (see figure 1.)    Just as 145 in decimal is equal to 1*10 2+4*10 1+4*10 0, the binaru number 0101 is equal to 0*2 3+1*2 2+0*2 1+1*2 0, which equals 5 in decimal.     Conversion from decimal to binay involves repeated division by two, and works like this:  divide the decimal number by 2. The remainder is your binary digit.  Now divide the quotinent by 2 to get the next digit--repeat this process until a quotient of zero is reached (see figure 3.)     Just as a hex number is preceded by a $, binary numbers start with a %. %1001 is equal to $9 and decimal 9.     Hexadecimal is base 16, thus it has the digits  1 - 9, and A,B,C,D,E,F (see figure 1). Just as the decimal numer 153 can be represented as 1*100+5*10+3, the hex number A3F can be represented as 10*256+3*16+15.  This is how you convert a number from hex to decimal. The hex number abcd is equal to a*16 3+b*16 2+c*16 1+d*16 0.     Conversion from decimal to hex is a little harder.  It involves repeated division by 16 until a quotient of 0 is reached (see figure 2). After each divison by 16, the remainder is the next hex digit. Now divide the quotient by 16, the remainder is the next hex digit.  Keep doing this until a quotient of 0 is reached.     Just as binary number are preceded by a percent sign, hexaecimal numbers often begin with a dollar sign. For example, 1000 hex is writen $1000 so you know it is not decimal.     Notice that a hex $F is equal to %1111.  This makes conversion between hex and binary easy; every 4 binary digits equals one hex digit. Thus, $1A is equal to %00011010 and $54 equals %01010100     To help make conversion between the number systems easy, I have included a program to do it for you (see listing 1.)  This program will accept a number in base 2,10, or 16 (just precede the number with $ for hex and % for binary,) and it will show the equivalent values in all three bases.  You can also use this program to check your answers if you wish to practice number conversions by hand.     Thats all for this month--next month i'll begin covering some basic assembly instructions and show you how to work an assembler. Hope to see you then. à    >6 M  Pe                                                                                                   