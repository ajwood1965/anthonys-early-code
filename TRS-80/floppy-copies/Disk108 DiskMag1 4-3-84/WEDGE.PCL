;*************************************;*                                   *;*           c-64 dos wedge          *;*                                   *;*              04-27-79             *;*                                   *;*           bob  fairbairn          *;*                                   *;*************************************;*                                   *;* version 3.1 6/14/79               *;*    add @ prompt for business      *;*    keyboard. add stop key check   *;*    in directory print. add        *;*    halt in directory print        *;*                                   *;* version 3.2 7/2/79                *;*    for (-04) rom problems         *;*    with load address one off      *;*    byte low.                      *;*                                   *;* version 3.3 7/2/79                *;*    add stack lookup for           *;*    activation.                    *;*                                   *;* version 4.0 7/5/79                *;*    add control for cmd during     *;*    a directory listing.           *;*                                   *;*                                   *;* version 4.1 11/7/79               *;*    remove mods from 4.0. call     *;*    fast wedge 4.1.                *;*                                   *;*                                   *;* version 4.2 12/17/79              *;*    set up for basic 4.0 and       *;*    2.0 (no changes)               *;*                                   *;*                                   *;* version 5.0 12/16/81-02/10/82     *;*    add new commands, allow to     *;*    work in a running program.     *;*    put volume names in all        *;*    commands using brackets.       *;*    only works with basic4.0       *;*                                   *;*                                   *;* version 5.1/64  06/07/82-07/13/82 *;*    make work with commodore 64    *;*                                   *;************************************* .page;;basic variables used;sal =$ac ;indirect pointer losah =$ad ;hibufpt =$a6 ;cassette (two bytes)cntdn =$a5 ;save areatxttab =$2b ;pointer to basic startmemsiz =$37 ;pointer to top memtxtptr =$7a ;pointer to bufsatus =$90 ;status bytesa =$b9 ;secondary addressfa =$ba ;primary addressla =$b8 ;logical device #fnlen =$b7 ;file name lengthfnadr =$bb ;file name addresseal =$ae ;end addr loeah =$af ;histal =$c1 ;lo bytestah =$c2 ;hi bytevartab =$2d ;end of basic pgm.tmp2 =$c3 ;temp variablebuf =$0200 ;input buffer;;program variables;cr =$0d ;symbolic carriage return .page;;cbm 64  routines used (2.0 basic);main =$a48c ;where called from(main+12)linprt =$bdcd ;print line #clsei =$f642 ;close a fileloadsp =$ffd5 ;load routinechrget =$73 ;inputs characterschrgot =$79 ;get last chargone =$a7e6 ; statement exec(ngone+2)snerr =$af08 ; syntax error printchdgot =$e3a8 ;rom copy of chrgotnewstt =$a7ae ;new statement execprt =$e716 ;print a characterlistn =$ffb1 ;send listensetmsg =$ff90 ;set kernal messagessecnd =$ff93 ;send saciout =$ffa8 ;send characterunlsn =$ffae ;un listenacptr =$ffa5 ;get a charcatertalk =$ffb4 ;send talkopeni =$f3d5 ;open fileready =$e386 ;reenter basicrunc =$a659 ;clear variables and stacklnkprg =$a533 ;link basic linesuntlk =$ffab ;un talkstxtpt =$a68e ;set start text pointerstop =$ffe1 ;check for stop keycsave =$e156+3 ;save with address set (basic)tksa =$ff96 ;talk secondary addressgetin =$ffe4 ;get a character.page 'wedge parser';;wedge in routine with the;command parser and executition;*=$cc00jmp goootabhi.byt >zz1 ;%        load (non relo).byt >zz1 ;/        load.byt >zz1 ;/ token    ".byt >zz2 ;^        load/run.byt >zz2 ;^ token   "    ".byt >zz3 ;_        save.byt >zz4 ;>        disk command.byt >zz4 ;> token    "     ".byt >zz4 ;@          "     ".byt >zz5 ;#        change device.byt >zz6 ;q        quit;tablo.byt <zz1 ;%.byt <zz1 ;/.byt <zz1 ;/ token.byt <zz2 ;^.byt <zz2 ;^ token.byt <zz3 ;_.byt <zz4 ;>.byt <zz4 ;> token.byt <zz4 ;@.byt <zz5 ;#.byt <zz6 ;q;ncmd =9 ;number of main commandscmd .byt '%/',$ad,'^',$ae,'_','>',$b1,'@#q',$00;commands  % / / ^ ^ _ > > @ # q;commands  1 2 3 4 5 6 7 8 9 a bprefix *=*+2file *=*+1 ;data for disk is stored herefile1 *=*+79svfa *=*+1 ;save favol *=*+1 ;volume namelastch *=*+1 ;last char from chrgetflag *=*+1 ;save commandmsgs .byt $d,$d,'      dos manager v5.1/071382',$d.byt $d, '         by  bob fairbairn',$d.byt $d, '(c) 1982 commodore business machines',$d,$0jump jmp start ;overlay for z-page 'chrgot'.page 'init code; vector';; init the memory manager (startup comes here);gooo ldx #$02 ;move three byteswedge lda jump,x sta chrgot+3,x dex bpl wedge; lda fa ;use current fa for device addr sta svfa;; say hello and exit; jmp msg ;print hello (jsr/rts);; this is where we come to do the work;start sta bufpt ;save .a, .x stx bufpt+1 tsx ;activated  call in 'gone' lda $0101,x cmp #<gone ;from a running program?? beq trytwo cmp #<main ;from direct mode?? bne notcmdtrytwo lda $0102,x cmp #>gone ;program? beq findit cmp #>main ;direct? bne notcmdfindit lda bufpt ;get the command back ldx #ncmd-1findc ;find the command cmp cmd,x beq call10 dex bpl findc;notcmd lda bufpt ;restore regs ldx bufpt+1 cmp #': ;complete chrgot bcs strts jmp chrgot+7strts jmp chrgot+17 ;to the end of chrgot;call10 stx cntdn ;save index sta flag ;save the command for later jsr rdfile ;get the filename and length ldx cntdn ;restore index lda #<file ;set filename address sta fnadr lda #>file sta fnadr+1 lda svfa ;set primary address sta fa;callit lda tabhi,x ;found command...go there pha lda tablo,x pha rts.pag;;main action routine for wedge commands '>@';doit tya ;.y has fnlen beq rderr ;no data so read e. c.; ldx #ncmd ;now check for sub-commandschksub lda cmd,x beq chklst ;ran out... cmp file ;is this a command? beq fndsub ;yes... inx bpl chksub;chklst ;not a sub-command lda file ;is this a dir command cmp #'$ beq dodir ;directory stuff jmp notdir ;disk commands;;fndsub ;found sub command dec fnlen ;setup and go there lda #<file1 sta fnadr lda #>file1 sta fnadr+1 jmp callit.page 'disk cmd & e. c.';; send command to disk;notdir lda fa ;device address jsr listn lda #$6f sta sa jsr secnd ;send secondary addr ldy #0bump lda file,y jsr ciout iny cpy fnlen bcc bump ;more;wg120 jsr unlsn ;un listen jmp wg998;; read the error channel;rderr lda fa ;device address jsr talk lda #$6f ;command channel sa sta sa jsr tksa ;send sa talk stylewg140 jsr acptr ;get byte from disk cmp #cr beq wg130 jsr prt ;print byte to screen jmp wg140 ;loop for morewg130 jsr prt ;print cr jsr untlk ;un talkwg998 jmp chrgot ;done with cmd.page 'directory read';;print the directory '@$0:*';dodir lda #$60 ;secondary addr sta sa jsr openi ;open the file lda fa ;get primary address jsr talk lda sa ;get secondary address jsr tksa.ski lda #0 sta satus ;set status to 0 ldy #$03 ;loop three timeswg220 sty fnlen ;save new count jsr acptr sta tmp2 jsr acptr sta tmp2+1 ldy satus ;check status bne wg230 ldy fnlen ;more to do? dey bne wg220 ;not done yet ldx tmp2 lda tmp2+1 jsr linprt ;print line number lda #$20 ;print a space jsr prtwg250 jsr acptr ldx satus bne wg230 ;bad cmp #0 ;eol beq wg240 jsr prt;check for stop key and pause jsr stop ;stop key beq wg230 ;yes... jsr getin ;get a char from keyboard beq wg250 ;nothing... cmp #$20 ;space bar for pause? bne wg250 ;no...wg255 jsr getin ;any key starts beq wg255 bne wg250 ;(jmp);wg240 lda #cr jsr prt ldy #$02 ; do twice jmp wg220;;close floppy and return;wg230 jsr clsei ;close file lda #cr ;print a return jsr prt jmp chrgot ;return.page 'file load/run';;    load or load and run a file;  (fnlen is set and the name is in file);  %filename ...... load (non relocating);  /filename ...... load;  ^filename ...... load/run;runrload ldx txttab ;set pointer for auto locate ldy txttab+1 lda flag ;set type of load cmp #'% bne load0 lda #1 .byt $2c ;skip2load0 lda #0 sta sa lda #$0 jsr loadsp ;load a program bcs lderr ;trouble in river city lda flag ;load type cmp #'% ;is it an absolute load beq load1 ;yes lda eah ;set basic's pointers sta vartab+1 lda eal sta vartab jsr runc ;fix pointers jsr lnkprg ;fix links lda flag ;check for load or run cmp #$ad ;load command is / (token) beq load1 ;yes...load only cmp #'/ ;load command is / bne wg300 ;no...load/runload1 jmp ready ;load return to basicwg300 lda #$00 ;no kernal messages jsr setmsg jsr stxtpt ;set txtptr for run jmp newstt ;run programlderr ;load error jmp ready.page 'quit, save, change';; quit command '@q';quit ldx #$02rest ;restore 'chrget' lda chdgot+3,x sta chrgot+3,x dex bpl rest jmp ready;;save command '_filename';save ;save a file jsr csave ;call basic save routine just past parsing jmp rderr ;read thee ec after save;; change the default device number '@#9';chgdev ldy fnlen lda file,y and #$0f ;convert ascii to binary sta svfa dey beq chg10 ;only one number; lda file,y and #$0f tay ;use first digit as count beq chg10 lda svfa clcchg05 adc #10 ;add 10 for each count dey bne chg05 sta svfa ;save resultchg10 jmp chrgot.page 'subroutines';; read filename string from command; and place it into file string;rdfile ldy #0 jsr chrget tax bne rd05 ;more to do... jmp setlen ;done...rd05 lda #$60 ;do not skip blanks or call me chrget sta chrgot+3 lda txtptr ;save pointer to data pha lda txtptr+1 pha txa ;put first char into .ard10 cmp #'" ;look for quote beq rd20 jsr chrget ;get next character bne rd10 pla ;did not find quote (read all of line) sta txtptr+1 ;restore pointer pla sta txtptr jsr chrgot ;get first character on line ldx #0 ;file name length count cmp #'" ;looking at quote? beq fill ;yes...(must be when running) ldx #>buf ;if in direct mode then ok cpx txtptr+1 bne filer1 ;must have a quote ldx #0 beq fill10 ;(branch)rd20 pla ;found quote do our thing pla ldx #0;fill jsr chrget beq setlenfill10 cmp #'" ;end quote? beq setlen cmp #'= ;filename start beq fill20 cmp #': ;filename start bne storitfill20 ldx #$ff ;do not countstorit cmp #'[ ;start vol stuff? beq fill30 ;yes...stor10 sta file,y sta lastch inx iny bpl fill;fill30 jsr chrget ;get vol name beq filer1 ;required sta vol ;save it jsr chrget ;get closing delimiter beq filer1 ;must be there??... cmp #'] bne filer1 ;wrong delimiter....; cpx #16 ;see if name is too long bcs filer1 lda lastch ;if last is * then fill ? cmp #'* bne filspc dey ;do not put in the * dex lda #'? .byt $2cfilspc lda #$20 ;else fill with spacefilpat cpx #15 ;are we done yet ? bcs filend ;yes... sta file,y iny inx bpl filpatfilend lda vol ;put in the volume name bne stor10 ;branch;filer1 ;blow off to syntax error ldx #$4c ;restore chrgot stx chrgot+3 jmp snerr;setlen sty fnlen ;save length ldx #$4c ;restore chrgot stx chrgot+3; jsr chrgot ;throw away the rest of the line beq setrtssetclr jsr chrget bne setclr;setrts ;done rts;;; print the sign on msg;msg ldx #$00outlp lda msgs,x beq msgd jsr prt inx bne outlpmsgd rts;;these must be after the definitions;zz1 =load-1 ;load a programzz2 =runr-1 ;run a programzz3 =save-1 ;save a programzz4 =doit-1 ;> callzz5 =chgdev-1 ;change device numberzz6 =quit-1 ;leave dos support.end        